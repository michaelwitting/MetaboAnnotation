[{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation package defines high-level user functionality support facilitate annotation MS-based metabolomics data (Rainer et al. 2022).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Annotation of MS-based Metabolomics Data","text":"package can installed BiocManager package. install BiocManager use install.packages(\"BiocManager\") , , BiocManager::install(\"MetaboAnnotation\") install package.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"general-description","dir":"Articles","previous_headings":"","what":"General description","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation provides set matching functions allow comparison (matching) query target entities. entities can chemical formulas, numeric values (e.g. m/z retention times) fragment spectra. available matching functions : matchFormula: match chemical formulas. matchSpectra: match fragment spectra. matchValues (formerly matchMz): match numerical values (m/z, masses, retention times etc). matching functions parameter objects available allow different types matching algorithms. Refer help pages detailed listing (e.g. ?matchFormula, ?matchSpectra ?matchValues). result, Matched (MatchedSpectra) object returned streamlines simplifies handling potential one--many (one--none) matching.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"example-use-cases","dir":"Articles","previous_headings":"","what":"Example use cases","title":"Annotation of MS-based Metabolomics Data","text":"following sections illustrate example use cases functionality provided MetaboAnnotation package.","code":"library(MetaboAnnotation)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z values","title":"Annotation of MS-based Metabolomics Data","text":"section simple matching feature m/z values theoretical m/z values performed. lowest level confidence metabolite annotation. However, gives ideas potential metabolites can analyzed downstream experiments analyses. following example loads feature table lipidomics experiments matches measured m/z values reference masses LipidMaps. use data.frame reference database, CompDb compound database instance also supported. reference (target) compounds mass available. need convert mass m/z values order match m/z values features (.e. query m/z values) . need define likely ions/adducts generated compounds based ionization used experiment. assume abundant adducts compounds \"[M+H]+\" \"[M+Na]+. next perform matching matchValues function providing query target data well parameter object (case Mass2MzParam) settings matching. Mass2MzParam, mass target compounds get first converted m/z values, based defined adducts, matched query m/z values (.e. m/z values features). get full list supported adducts MetaboCoreUtils::adductNames(polarity = \"positive\") MetaboCoreUtils::adductNames(polarity = \"negative\") can used). Note also, keep runtime vignette short, match first 100 features. tested 100 features 55 matched least one target compound (matches single compound). result object (type Matched) contains full query data frame target data frames well matching information. can access original query data query original target data target function: Functions whichQuery whichTarget can used identify rows query target data matched: colnames function can used evaluate variables/columns available Matched object. columns query, columns target (prefix \"target_\" added original column names target) information matching result (case columns \"adduct\", \"score\" \"ppm_error\"). can extract full matching table matchedData. returns DataFrame rows query corresponding matches target along matching adduct (column \"adduct\") difference m/z (column \"score\" absolute differences \"ppm_error\" m/z relative differences). Note row query matches multiple elements target, row duplicated DataFrame returned data. rows can matched NA values reported. Individual columns can simply extracted $ operator: NA reported query entries match found. See also help page ?Matched details information. addition matching query m/z target exact masses described also possible match directly query m/z target m/z values using MzParam instead Mass2MzParam.","code":"ms1_features <- read.table(system.file(\"extdata\", \"MS1_example.txt\",                                        package = \"MetaboAnnotation\"),                            header = TRUE, sep = \"\\t\") head(ms1_features) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 target_df <- read.table(system.file(\"extdata\", \"LipidMaps_CompDB.txt\",                                     package = \"MetaboAnnotation\"),                         header = TRUE, sep = \"\\t\") head(target_df) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even parm <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                            tolerance = 0.005, ppm = 0)  matched_features <- matchValues(ms1_features[1:100, ], target_df, parm) matched_features ## Object of class Matched  ## Total number of matches: 55  ## Number of query objects: 100 (55 matched) ## Number of target objects: 57599 (1 matched) head(query(matched_features)) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 head(target(matched_features)) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even whichQuery(matched_features) ##  [1]  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64 ## [20]  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83 ## [39]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 whichTarget(matched_features) ## [1] 3149 colnames(matched_features) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"adduct\"            ## [10] \"score\"             \"ppm_error\" matchedData(matched_features) ## DataFrame with 100 rows and 11 columns ##        feature_id        mz     rtime target_headgroup target_name ##       <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_00...   102.128   1.56015               NA          NA ## 2   Cluster_00...   102.128   2.15359               NA          NA ## 3   Cluster_00...   102.128   2.92557               NA          NA ## 4   Cluster_00...   102.128   3.41962               NA          NA ## 5   Cluster_00...   102.127   5.80104               NA          NA ## ...           ...       ...       ...              ...         ... ## 96  Cluster_00...   201.113   11.2722               FA  FA 10:2;O2 ## 97  Cluster_00...   201.113   11.4081               FA  FA 10:2;O2 ## 98  Cluster_00...   201.113   11.4760               FA  FA 10:2;O2 ## 99  Cluster_00...   201.114   11.5652               FA  FA 10:2;O2 ## 100 Cluster_01...   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type      adduct     score ##            <numeric>    <character>       <character> <character> <numeric> ## 1                 NA             NA                NA          NA        NA ## 2                 NA             NA                NA          NA        NA ## 3                 NA             NA                NA          NA        NA ## 4                 NA             NA                NA          NA        NA ## 5                 NA             NA                NA          NA        NA ## ...              ...            ...               ...         ...       ... ## 96           200.105       C10H16O4              even      [M+H]+ 0.0007312 ## 97           200.105       C10H16O4              even      [M+H]+ 0.0005444 ## 98           200.105       C10H16O4              even      [M+H]+ 0.0005328 ## 99           200.105       C10H16O4              even      [M+H]+ 0.0014619 ## 100          200.105       C10H16O4              even      [M+H]+ 0.0020342 ##     ppm_error ##     <numeric> ## 1          NA ## 2          NA ## 3          NA ## 4          NA ## 5          NA ## ...       ... ## 96    3.63578 ## 97    2.70695 ## 98    2.64927 ## 99    7.26908 ## 100  10.11476 matched_features$target_name ##   [1] NA           NA           NA           NA           NA           ##   [6] NA           NA           NA           NA           NA           ##  [11] NA           NA           NA           NA           NA           ##  [16] NA           NA           NA           NA           NA           ##  [21] NA           NA           NA           NA           NA           ##  [26] NA           NA           NA           NA           NA           ##  [31] NA           NA           NA           NA           NA           ##  [36] NA           NA           NA           NA           NA           ##  [41] NA           NA           NA           NA           NA           ##  [46] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [51] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [56] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [61] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [66] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [71] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [76] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [81] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [86] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [91] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [96] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-and-retention-time-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z and retention time values","title":"Annotation of MS-based Metabolomics Data","text":"expected retention time values available target compounds, annotation higher confidence performed matchValues Mass2MzRtParam parameter object. illustrate randomly assign retention times query features target compounds adding also 2 seconds difference. real use case target data.frame contain masses (m/z values) standards along retention times ions standards measured LC-MS setup query data derives. subset data table MS1 features first 100 rows (keep runtime vignette short). table contains thus retention times features column named \"rtime\". Next randomly assign retention times features compounds target data adding deviation 2 seconds. described , real use case retention times supposed determined measuring compounds LC-MS setup. now retention times available query target data can thus perform matching based m/z retention times. use Mass2MzRtParam allows us specify (Mass2MzParam) expected adducts, maximal acceptable m/z relative absolute deviation well maximal acceptable (absolute) difference retention times. use settings previous section allow difference 10 seconds retention times. retention times provided columns named \"rtime\" different default (\"rt\"). thus specify name column containing retention times parameter rtColname. Less features matched based m/z retention times.","code":"ms1_subset <- ms1_features[1:100, ] head(ms1_subset) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 set.seed(123) target_df$rtime <- sample(ms1_subset$rtime,                           nrow(target_df), replace = TRUE) + 2 parm <- Mass2MzRtParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                        tolerance = 0.005, ppm = 0,                        toleranceRt = 10) matched_features <- matchValues(ms1_subset, target_df, param = parm,                                 rtColname = \"rtime\") matched_features ## Object of class Matched  ## Total number of matches: 31  ## Number of query objects: 100 (31 matched) ## Number of target objects: 57599 (1 matched) matchedData(matched_features)[whichQuery(matched_features), ] ## DataFrame with 31 rows and 13 columns ##        feature_id        mz     rtime target_headgroup target_name ##       <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_00...   201.113   5.87206               FA  FA 10:2;O2 ## 2   Cluster_00...   201.113   5.93346               FA  FA 10:2;O2 ## 3   Cluster_00...   201.113   6.03653               FA  FA 10:2;O2 ## 4   Cluster_00...   201.114   6.16709               FA  FA 10:2;O2 ## 5   Cluster_00...   201.113   6.31781               FA  FA 10:2;O2 ## ...           ...       ...       ...              ...         ... ## 27  Cluster_00...   201.113   11.2722               FA  FA 10:2;O2 ## 28  Cluster_00...   201.113   11.4081               FA  FA 10:2;O2 ## 29  Cluster_00...   201.113   11.4760               FA  FA 10:2;O2 ## 30  Cluster_00...   201.114   11.5652               FA  FA 10:2;O2 ## 31  Cluster_01...   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type target_rtime      adduct ##            <numeric>    <character>       <character>    <numeric> <character> ## 1            200.105       C10H16O4              even      15.8624      [M+H]+ ## 2            200.105       C10H16O4              even      15.8624      [M+H]+ ## 3            200.105       C10H16O4              even      15.8624      [M+H]+ ## 4            200.105       C10H16O4              even      15.8624      [M+H]+ ## 5            200.105       C10H16O4              even      15.8624      [M+H]+ ## ...              ...            ...               ...          ...         ... ## 27           200.105       C10H16O4              even      15.8624      [M+H]+ ## 28           200.105       C10H16O4              even      15.8624      [M+H]+ ## 29           200.105       C10H16O4              even      15.8624      [M+H]+ ## 30           200.105       C10H16O4              even      15.8624      [M+H]+ ## 31           200.105       C10H16O4              even      15.8624      [M+H]+ ##         score ppm_error  score_rt ##     <numeric> <numeric> <numeric> ## 1   0.0004538   2.25645  -9.99030 ## 2   0.0004407   2.19131  -9.92890 ## 3   0.0005655   2.81186  -9.82583 ## 4   0.0015560   7.73698  -9.69527 ## 5   0.0006845   3.40357  -9.54455 ## ...       ...       ...       ... ## 27  0.0007312   3.63578  -4.59014 ## 28  0.0005444   2.70695  -4.45431 ## 29  0.0005328   2.64927  -4.38634 ## 30  0.0014619   7.26908  -4.29719 ## 31  0.0020342  10.11476  -4.08719"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-summarizedexperiment-or-qfeatures-objects","dir":"Articles","previous_headings":"Example use cases","what":"Matching of SummarizedExperiment or QFeatures objects","title":"Annotation of MS-based Metabolomics Data","text":"Results LC-MS preprocessing (e.g. xcms package) generally metabolomics results might best represented bundled SummarizedExperiment QFeatures objects (-named Bioconductor packages). XCMSnExp preprocessing result xcms can example converted SummarizedExperiment using quantify method xcms package. feature definitions (.e. m/z retention time values) stored object’s rowData assay (numerical matrix) contain feature abundances across samples. SummarizedExperiment objects can simply passed query objects matchValues method. illustrate , create simple SummarizedExperiment using ms1_features data frame example rowData adding matrix random values assay. can now use matchValues call perform matching. Matching performed object’s rowData, .e. row/element SummarizedExperiment matched target using e.g. m/z values available columns object’s rowData: query, result contains full SummarizedExperiment, colnames matchedData access respective information rowData SummarizedExperiment: Subsetting result object, e.g. just matched elements also subset SummarizedExperiment. QFeatures object essentially container several SummarizedExperiment objects rows (features) related . object thus example contain full feature data LC-MS experiment one assay compounded feature data data ions compound aggregated additional assay. create object using SummarizedExperiment assay name \"features\". now don’t add additional assay QFeatures, thus, object contains single data set. matchValues supports also matching QFeatures objects user needs define assay used matching queryAssay parameter. colnames matchedData allow access rowData SummarizedExperiment stored QFeatures’ \"features\" assay:","code":"library(SummarizedExperiment) ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ##  ## Attaching package: 'MatrixGenerics' ## The following objects are masked from 'package:matrixStats': ##  ##     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ##     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ##     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ##     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ##     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ##     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ##     colWeightedMeans, colWeightedMedians, colWeightedSds, ##     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ##     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ##     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ##     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ##     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ##     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ##     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ##     rowWeightedSds, rowWeightedVars ## Loading required package: GenomicRanges ## Loading required package: stats4 ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, append, as.data.frame, basename, cbind, colnames, ##     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep, ##     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, ##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ##     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, ##     union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ##  ## Attaching package: 'S4Vectors' ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: GenomeInfoDb ## Loading required package: Biobase ## Welcome to Bioconductor ##  ##     Vignettes contain introductory material; view with ##     'browseVignettes()'. To cite Bioconductor, see ##     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. ##  ## Attaching package: 'Biobase' ## The following object is masked from 'package:MatrixGenerics': ##  ##     rowMedians ## The following objects are masked from 'package:matrixStats': ##  ##     anyMissing, rowMedians se <- SummarizedExperiment(     assays = matrix(nrow = nrow(ms1_features), ncol = 4),     rowData = ms1_features) parm <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                      tolerance = 0.005, ppm = 0) matched_features <- matchValues(se, target_df, param = parm) matched_features ## Object of class Matched  ## Total number of matches: 9173  ## Number of query objects: 2842 (1969 matched) ## Number of target objects: 57599 (3296 matched) colnames(matched_features) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"target_rtime\"      ## [10] \"adduct\"            \"score\"             \"ppm_error\" matchedData(matched_features) ## DataFrame with 10046 rows and 12 columns ##          feature_id        mz     rtime target_headgroup   target_name ##         <character> <numeric> <numeric>      <character>   <character> ## 1     Cluster_00...   102.128   1.56015               NA            NA ## 2     Cluster_00...   102.128   2.15359               NA            NA ## 3     Cluster_00...   102.128   2.92557               NA            NA ## 4     Cluster_00...   102.128   3.41962               NA            NA ## 5     Cluster_00...   102.127   5.80104               NA            NA ## ...             ...       ...       ...              ...           ... ## 10042 Cluster_28...   957.771   20.2705               TG    TG 54:2;O3 ## 10043 Cluster_28...   960.791   20.8865           HexCer HexCer 52:... ## 10044 Cluster_28...   961.361   13.0214               NA            NA ## 10045 Cluster_28...   970.873   22.0981             ACer ACer 60:1;... ## 10046 Cluster_28...   972.734   15.6914          Hex2Cer Hex2Cer 42... ##       target_exactmass target_formula target_chain_type target_rtime ##              <numeric>    <character>       <character>    <numeric> ## 1                   NA             NA                NA           NA ## 2                   NA             NA                NA           NA ## 3                   NA             NA                NA           NA ## 4                   NA             NA                NA           NA ## 5                   NA             NA                NA           NA ## ...                ...            ...               ...          ... ## 10042          934.784      C57H106O9              even      15.9950 ## 10043          959.779     C58H105NO9              even      10.5076 ## 10044               NA             NA                NA           NA ## 10045          947.888     C60H117NO6              even       4.2806 ## 10046          971.727  C54H101NO1...              even      19.7329 ##            adduct      score ppm_error ##       <character>  <numeric> <numeric> ## 1              NA         NA        NA ## 2              NA         NA        NA ## 3              NA         NA        NA ## 4              NA         NA        NA ## 5              NA         NA        NA ## ...           ...        ...       ... ## 10042     [M+Na]+ -0.0021897  2.286241 ## 10043      [M+H]+  0.0045398  4.725089 ## 10044          NA         NA        NA ## 10045     [M+Na]+ -0.0045054  4.640545 ## 10046      [M+H]+ -0.0004240  0.435885 matched_sub <- matched_features[whichQuery(matched_features)] query(matched_sub) ## class: SummarizedExperiment  ## dim: 1969 4  ## metadata(0): ## assays(1): '' ## rownames: NULL ## rowData names(3): feature_id mz rtime ## colnames: NULL ## colData names(0): library(QFeatures) ## Loading required package: MultiAssayExperiment ##  ## Attaching package: 'QFeatures' ## The following object is masked from 'package:MultiAssayExperiment': ##  ##     longFormat ## The following object is masked from 'package:base': ##  ##     sweep qf <- QFeatures(list(features = se)) qf ## An instance of class QFeatures containing 1 assays: ##  [1] features: SummarizedExperiment with 2842 rows and 4 columns matched_qf <- matchValues(qf, target_df, param = parm, queryAssay = \"features\") matched_qf ## Object of class Matched  ## Total number of matches: 9173  ## Number of query objects: 2842 (1969 matched) ## Number of target objects: 57599 (3296 matched) colnames(matched_qf) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"target_rtime\"      ## [10] \"adduct\"            \"score\"             \"ppm_error\" matchedData(matched_qf) ## DataFrame with 10046 rows and 12 columns ##          feature_id        mz     rtime target_headgroup   target_name ##         <character> <numeric> <numeric>      <character>   <character> ## 1     Cluster_00...   102.128   1.56015               NA            NA ## 2     Cluster_00...   102.128   2.15359               NA            NA ## 3     Cluster_00...   102.128   2.92557               NA            NA ## 4     Cluster_00...   102.128   3.41962               NA            NA ## 5     Cluster_00...   102.127   5.80104               NA            NA ## ...             ...       ...       ...              ...           ... ## 10042 Cluster_28...   957.771   20.2705               TG    TG 54:2;O3 ## 10043 Cluster_28...   960.791   20.8865           HexCer HexCer 52:... ## 10044 Cluster_28...   961.361   13.0214               NA            NA ## 10045 Cluster_28...   970.873   22.0981             ACer ACer 60:1;... ## 10046 Cluster_28...   972.734   15.6914          Hex2Cer Hex2Cer 42... ##       target_exactmass target_formula target_chain_type target_rtime ##              <numeric>    <character>       <character>    <numeric> ## 1                   NA             NA                NA           NA ## 2                   NA             NA                NA           NA ## 3                   NA             NA                NA           NA ## 4                   NA             NA                NA           NA ## 5                   NA             NA                NA           NA ## ...                ...            ...               ...          ... ## 10042          934.784      C57H106O9              even      15.9950 ## 10043          959.779     C58H105NO9              even      10.5076 ## 10044               NA             NA                NA           NA ## 10045          947.888     C60H117NO6              even       4.2806 ## 10046          971.727  C54H101NO1...              even      19.7329 ##            adduct      score ppm_error ##       <character>  <numeric> <numeric> ## 1              NA         NA        NA ## 2              NA         NA        NA ## 3              NA         NA        NA ## 4              NA         NA        NA ## 5              NA         NA        NA ## ...           ...        ...       ... ## 10042     [M+Na]+ -0.0021897  2.286241 ## 10043      [M+H]+  0.0045398  4.725089 ## 10044          NA         NA        NA ## 10045     [M+Na]+ -0.0045054  4.640545 ## 10046      [M+H]+ -0.0004240  0.435885"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-msms-spectra","dir":"Articles","previous_headings":"Example use cases","what":"Matching of MS/MS spectra","title":"Annotation of MS-based Metabolomics Data","text":"section match experimental MS/MS spectra reference spectra. can also performed functions Spectra package (see SpectraTutorials, functions concepts used suitable end user simplify handling spectra matching results. load spectra file reversed-phase (DDA) LC-MS/MS run Agilent Pesticide mix. filterMsLevel subset data set MS2 spectra. reduce processing time example subset Spectra small set selected MS2 spectra. addition assign feature identifiers spectrum (, example arbitrary IDs, real data analysis identifiers indicate LC-MS feature spectra belong). Spectra now represent MS2 spectra associated LC-MS features untargeted LC-MS/MS experiment like annotate matching spectral reference library. thus load Spectra object represents MS2 data small subset MassBank release 2021.03. small Spectra object provided within package possible use Spectra object instead (see SpectraTutorials different ways options provide access spectral libraries/databases via Spectra). can now use matchSpectra function match experimental query spectra target (reference) spectra. Settings matching can defined dedicated param object. use CompareSpectraParam uses compareSpectra function Spectra package calculate similarities query spectrum target spectra. CompareSpectraParam allows set individual settings compareSpectra call parameters MAPFUN, ppm, tolerance FUN (see help compareSpectra Spectra package details). addition, can pre-filter target spectra individual query spectrum speed-calculations. setting requirePrecursor = TRUE compare query spectrum target spectra matching precursor m/z (accepting deviation defined parameters ppm tolerance). default, matchSpectra CompareSpectraParam considers spectra similarity score higher 0.7 matching thus reported. results reported MatchedSpectra object represents matching results query spectra. type object contains query spectra, target spectra, matching information parameter object settings matching. object can subsetted e.g. matching results specific query spectrum: case, first query spectrum, match found among target spectra. subset MatchedSpectra results second query spectrum: second query spectrum matched 4 target spectra. matching query target spectra can n:m, .e. query spectrum can match multiple target spectra target spectrum can matched none, one multiple query spectra. Data (spectra variables either query /target spectra) can extracted result object spectraData function $ (similar Spectra object). spectraVariables function can used list available spectra variables result object: lists spectra variables query target spectra, prefix \"target_\" used spectra variable names target spectra. Spectra variable \"score\" contains similarity score. thus use $target_compound_name extract compound name matching target spectra second query spectrum: information can also extracted full MatchedSpectra. use $spectrum_id extract query spectra identifiers added full result object. n:m mapping query target spectra, number values returned $ (spectraData) can larger total number query spectra. Also example , spectra IDs present result returned $spectrum_id. respective spectra matched one target spectrum (based settings) hence IDs reported multiple times. spectraData $ MatchedSpectra use left join strategy report/return values: value (row) reported query spectrum (even match target spectrum) eventually duplicated values (rows) query spectrum matches one target spectrum (value query spectrum repeated many times matches target spectra). illustrate use spectraData function extract specific data result object, .e. spectrum feature IDs query spectra defined , MS2 spectra similarity score, target spectra’s ID compound name. Using plotSpectraMirror function can visualize matching results one query spectrum. Note also interactive, shiny-based, validation matching results available validateMatchedSpectra function. call function show matches second spectrum.  unexpectedly, peak intensities query target spectra different scales. problem similarity calculation (normalized dot-product used default independent absolute peak values) ideal visualization. Thus, apply normalization function query target spectra plot spectra afterwards (see help addProcessing Spectra package details spectra data manipulations). function replace absolute spectra intensities intensities relative maximum intensity spectrum.  query spectrum seems nicely match identified target spectra. extract compound name target spectra second query spectrum. alternative CompareSpectraParam also use MatchForwardReverseParam matchSpectra. settings performs spectra similarity search CompareSpectraParam, reports addition (similar MS-DIAL) (forward) similarity score also reverse spectra similarity score well presence ratio matching spectra. default forward score calculated considering peaks query target spectrum (peak mapping performed using outer join strategy), reverse score calculated peaks present target spectrum matching peaks query spectrum (peak mapping performed using right join strategy). presence ratio ratio number mapped peaks query target spectrum total number peaks target spectrum. values available spectra variables \"reverse_score\" \"presence_ratio\" result object). perform spectra matching , using MatchForwardReverseParam. extract query target spectra IDs, compound name scores. examples matched query spectra target spectra precursor m/z ~ equal reported matches similarity higher 0.7. CompareSpectraParam, parameter THRESHFUN however also allow types analyses. example also report best matching target spectrum query spectrum, independently whether similarity score higher certain threshold. perform analysis defining THRESHFUN selects always best match. Note whole example work Spectra object MS2 spectra. objects also extracted xcms-based LC-MS/MS data analysis chromPeaksSpectra featureSpectra functions xcms package. Also, Matches can also validated using interactive Shiny app calling validateMatchedSpectra MatchedSpectra object. Individual matches can set TRUE FALSE app. closing app via Save & Close button filtered MatchedSpectra returned, containing matches manually validated.","code":"library(Spectra) library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L) ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)] ## assign arbitrary *feature IDs* to each spectrum. pest_ms2$feature_id <- c(\"FT001\", \"FT001\", \"FT002\", \"FT003\", \"FT003\", \"FT003\",                          \"FT004\", \"FT004\", \"FT004\", \"FT005\", \"FT005\", \"FT006\",                          \"FT006\") ## assign also *spectra IDs* to each pest_ms2$spectrum_id <- paste0(\"sp_\", seq_along(pest_ms2)) pest_ms2 ## MSn data (Spectra) with 13 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2   361.651      2853 ## 2           2   361.741      2854 ## 3           2   377.609      3030 ## 4           2   377.699      3031 ## 5           2   378.120      3033 ## ...       ...       ...       ... ## 9           2   378.959      3039 ## 10          2   379.379      3041 ## 11          2   380.059      3045 ## 12          2   380.609      3048 ## 13          2   381.029      3050 ##  ... 35 more variables/columns. ##  ## file(s): ## PestMix1_DDA.mzML ## Processing: ##  Filter: select MS level(s) 2 [Tue May 24 06:40:28 2022] load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\")) minimb ## MSn data (Spectra) with 100 spectra in a MsBackendDataFrame backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2        NA        NA ## 2           2        NA        NA ## 3           2        NA        NA ## 4           2        NA        NA ## 5           2        NA        NA ## ...       ...       ...       ... ## 96         NA        NA        NA ## 97          2        NA        NA ## 98          2        NA        NA ## 99          2        NA        NA ## 100         2        NA        NA ##  ... 42 more variables/columns. ## Processing: ##  Filter: select spectra with polarity 1 [Wed Mar 31 10:06:28 2021] ##  Switch backend from MsBackendMassbankSql to MsBackendDataFrame [Wed Mar 31 10:07:59 2021] mtches <- matchSpectra(pest_ms2, minimb,                        param = CompareSpectraParam(requirePrecursor = TRUE,                                                    ppm = 10)) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) mtches[1] ## Object of class MatchedSpectra  ## Total number of matches: 0  ## Number of query objects: 1 (0 matched) ## Number of target objects: 100 (0 matched) mtches[2] ## Object of class MatchedSpectra  ## Total number of matches: 4  ## Number of query objects: 1 (1 matched) ## Number of target objects: 100 (4 matched) spectraVariables(mtches) ##  [1] \"msLevel\"                        \"rtime\"                          ##  [3] \"acquisitionNum\"                 \"scanIndex\"                      ##  [5] \"dataStorage\"                    \"dataOrigin\"                     ##  [7] \"centroided\"                     \"smoothed\"                       ##  [9] \"polarity\"                       \"precScanNum\"                    ## [11] \"precursorMz\"                    \"precursorIntensity\"             ## [13] \"precursorCharge\"                \"collisionEnergy\"                ## [15] \"isolationWindowLowerMz\"         \"isolationWindowTargetMz\"        ## [17] \"isolationWindowUpperMz\"         \"peaksCount\"                     ## [19] \"totIonCurrent\"                  \"basePeakMZ\"                     ## [21] \"basePeakIntensity\"              \"ionisationEnergy\"               ## [23] \"lowMZ\"                          \"highMZ\"                         ## [25] \"mergedScan\"                     \"mergedResultScanNum\"            ## [27] \"mergedResultStartScanNum\"       \"mergedResultEndScanNum\"         ## [29] \"injectionTime\"                  \"filterString\"                   ## [31] \"spectrumId\"                     \"ionMobilityDriftTime\"           ## [33] \"scanWindowLowerLimit\"           \"scanWindowUpperLimit\"           ## [35] \"feature_id\"                     \"spectrum_id\"                    ## [37] \"target_msLevel\"                 \"target_rtime\"                   ## [39] \"target_acquisitionNum\"          \"target_scanIndex\"               ## [41] \"target_dataStorage\"             \"target_dataOrigin\"              ## [43] \"target_centroided\"              \"target_smoothed\"                ## [45] \"target_polarity\"                \"target_precScanNum\"             ## [47] \"target_precursorMz\"             \"target_precursorIntensity\"      ## [49] \"target_precursorCharge\"         \"target_collisionEnergy\"         ## [51] \"target_isolationWindowLowerMz\"  \"target_isolationWindowTargetMz\" ## [53] \"target_isolationWindowUpperMz\"  \"target_spectrum_id\"             ## [55] \"target_spectrum_name\"           \"target_date\"                    ## [57] \"target_authors\"                 \"target_license\"                 ## [59] \"target_copyright\"               \"target_publication\"             ## [61] \"target_splash\"                  \"target_compound_id\"             ## [63] \"target_adduct\"                  \"target_ionization\"              ## [65] \"target_ionization_voltage\"      \"target_fragmentation_mode\"      ## [67] \"target_collision_energy_text\"   \"target_instrument\"              ## [69] \"target_instrument_type\"         \"target_formula\"                 ## [71] \"target_exactmass\"               \"target_smiles\"                  ## [73] \"target_inchi\"                   \"target_inchikey\"                ## [75] \"target_cas\"                     \"target_pubchem\"                 ## [77] \"target_synonym\"                 \"target_precursor_mz_text\"       ## [79] \"target_compound_name\"           \"score\" mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mtches$spectrum_id ##  [1] \"sp_1\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_3\"  \"sp_4\"  \"sp_4\"  \"sp_5\"  ## [10] \"sp_6\"  \"sp_6\"  \"sp_6\"  \"sp_7\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  ## [19] \"sp_9\"  \"sp_9\"  \"sp_10\" \"sp_11\" \"sp_12\" \"sp_13\" mtches_df <- spectraData(mtches, columns = c(\"spectrum_id\", \"feature_id\",                                              \"score\", \"target_spectrum_id\",                                              \"target_compound_name\")) as.data.frame(mtches_df) ##    spectrum_id feature_id     score target_spectrum_id    target_compound_name ## 1         sp_1      FT001        NA               <NA>                    <NA> ## 2         sp_2      FT001 0.7869556           LU056604             Azaconazole ## 3         sp_2      FT001 0.8855473           LU056603             Azaconazole ## 4         sp_2      FT001 0.7234894           LU056602             Azaconazole ## 5         sp_2      FT001 0.7219942           LU056605             Azaconazole ## 6         sp_3      FT002        NA               <NA>                    <NA> ## 7         sp_4      FT003 0.7769746           KW108103 triphenylphosphineoxide ## 8         sp_4      FT003 0.7577286           KW108102 triphenylphosphineoxide ## 9         sp_5      FT003        NA               <NA>                    <NA> ## 10        sp_6      FT003 0.7433718           SM839501            Dimethachlor ## 11        sp_6      FT003 0.7019807           EA070705            Dimethachlor ## 12        sp_6      FT003 0.7081274           EA070711            Dimethachlor ## 13        sp_7      FT004        NA               <NA>                    <NA> ## 14        sp_8      FT004 0.7320465           SM839501            Dimethachlor ## 15        sp_8      FT004 0.8106258           EA070705            Dimethachlor ## 16        sp_8      FT004 0.7290458           EA070710            Dimethachlor ## 17        sp_8      FT004 0.8168876           EA070711            Dimethachlor ## 18        sp_8      FT004 0.7247800           EA070704            Dimethachlor ## 19        sp_9      FT004 0.7412586           KW108103 triphenylphosphineoxide ## 20        sp_9      FT004 0.7198787           KW108102 triphenylphosphineoxide ## 21       sp_10      FT005        NA               <NA>                    <NA> ## 22       sp_11      FT005        NA               <NA>                    <NA> ## 23       sp_12      FT006        NA               <NA>                    <NA> ## 24       sp_13      FT006        NA               <NA>                    <NA> plotSpectraMirror(mtches[2]) norm_int <- function(x) {     x[, \"intensity\"] <- x[, \"intensity\"] / max(x[, \"intensity\"], na.rm = TRUE)     x } mtches <- addProcessing(mtches, norm_int) plotSpectraMirror(mtches[2]) mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mp <- MatchForwardReverseParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, param = mp) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) as.data.frame(     spectraData(mtches, c(\"spectrum_id\", \"target_spectrum_id\",                           \"target_compound_name\", \"score\", \"reverse_score\",                           \"presence_ratio\"))) ##    spectrum_id target_spectrum_id    target_compound_name     score ## 1         sp_1               <NA>                    <NA>        NA ## 2         sp_2           LU056604             Azaconazole 0.7869556 ## 3         sp_2           LU056603             Azaconazole 0.8855473 ## 4         sp_2           LU056602             Azaconazole 0.7234894 ## 5         sp_2           LU056605             Azaconazole 0.7219942 ## 6         sp_3               <NA>                    <NA>        NA ## 7         sp_4           KW108103 triphenylphosphineoxide 0.7769746 ## 8         sp_4           KW108102 triphenylphosphineoxide 0.7577286 ## 9         sp_5               <NA>                    <NA>        NA ## 10        sp_6           SM839501            Dimethachlor 0.7433718 ## 11        sp_6           EA070705            Dimethachlor 0.7019807 ## 12        sp_6           EA070711            Dimethachlor 0.7081274 ## 13        sp_7               <NA>                    <NA>        NA ## 14        sp_8           SM839501            Dimethachlor 0.7320465 ## 15        sp_8           EA070705            Dimethachlor 0.8106258 ## 16        sp_8           EA070710            Dimethachlor 0.7290458 ## 17        sp_8           EA070711            Dimethachlor 0.8168876 ## 18        sp_8           EA070704            Dimethachlor 0.7247800 ## 19        sp_9           KW108103 triphenylphosphineoxide 0.7412586 ## 20        sp_9           KW108102 triphenylphosphineoxide 0.7198787 ## 21       sp_10               <NA>                    <NA>        NA ## 22       sp_11               <NA>                    <NA>        NA ## 23       sp_12               <NA>                    <NA>        NA ## 24       sp_13               <NA>                    <NA>        NA ##    reverse_score presence_ratio ## 1             NA             NA ## 2      0.8764394      0.5833333 ## 3      0.9239592      0.6250000 ## 4      0.7573541      0.6250000 ## 5      0.9519647      0.4285714 ## 6             NA             NA ## 7      0.9025051      0.7500000 ## 8      0.9164348      0.5000000 ## 9             NA             NA ## 10     0.8915201      0.5000000 ## 11     0.8687003      0.3333333 ## 12     0.8687472      0.3703704 ## 13            NA             NA ## 14     0.8444402      0.5000000 ## 15     0.9267965      0.5000000 ## 16     0.8765496      0.7500000 ## 17     0.9236674      0.4814815 ## 18     0.8714208      0.8571429 ## 19     0.8743130      0.7500000 ## 20     0.8937751      0.5000000 ## 21            NA             NA ## 22            NA             NA ## 23            NA             NA ## 24            NA             NA select_top_match <- function(x) {     which.max(x) } csp <- CompareSpectraParam(ppm = 10, requirePrecursor = FALSE,                            THRESHFUN = select_top_match) mtches <- matchSpectra(pest_ms2, minimb, param = csp) res <- spectraData(mtches, columns = c(\"spectrum_id\", \"target_spectrum_id\",                                        \"target_compound_name\", \"score\")) as.data.frame(res) ##    spectrum_id target_spectrum_id                   target_compound_name ## 1         sp_1           SM839603                             Flufenacet ## 2         sp_2           LU056603                            Azaconazole ## 3         sp_3           SM839501                           Dimethachlor ## 4         sp_4           KW108103                triphenylphosphineoxide ## 5         sp_5           LU100202        2,2'-(Tetradecylimino)diethanol ## 6         sp_6           SM839501                           Dimethachlor ## 7         sp_7           RP005503              Glycoursodeoxycholic acid ## 8         sp_8           EA070711                           Dimethachlor ## 9         sp_9           KW108103                triphenylphosphineoxide ## 10       sp_10           JP006901                  1-PHENYLETHYL ACETATE ## 11       sp_11           EA070711                           Dimethachlor ## 12       sp_12           EA070705                           Dimethachlor ## 13       sp_13           LU101704 2-Ethylhexyl 4-(dimethylamino)benzoate ##           score ## 1  0.000000e+00 ## 2  8.855473e-01 ## 3  6.313687e-01 ## 4  7.769746e-01 ## 5  1.772117e-05 ## 6  7.433718e-01 ## 7  1.906998e-03 ## 8  8.168876e-01 ## 9  7.412586e-01 ## 10 4.085289e-04 ## 11 4.323403e-01 ## 12 3.469648e-03 ## 13 7.612480e-06"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Annotation of MS-based Metabolomics Data","text":"","code":"## R version 4.2.0 (2022-04-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] msdata_0.37.0               Spectra_1.7.0               ##  [3] ProtGenerics_1.29.0         BiocParallel_1.31.4         ##  [5] QFeatures_1.7.0             MultiAssayExperiment_1.23.1 ##  [7] SummarizedExperiment_1.27.1 Biobase_2.57.1              ##  [9] GenomicRanges_1.49.0        GenomeInfoDb_1.33.3         ## [11] IRanges_2.31.0              S4Vectors_0.35.0            ## [13] BiocGenerics_0.43.0         MatrixGenerics_1.9.0        ## [15] matrixStats_0.62.0-9000     MetaboAnnotation_1.1.1      ## [17] BiocStyle_2.25.0            ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.8.3            lattice_0.20-45         rprojroot_2.0.3         ##  [4] digest_0.6.29           R6_2.5.1                evaluate_0.15           ##  [7] highr_0.9               zlibbioc_1.43.0         rlang_1.0.2             ## [10] lazyeval_0.2.2          jquerylib_0.1.4         MetaboCoreUtils_1.5.1   ## [13] Matrix_1.4-1            rmarkdown_2.14          mzR_2.31.0              ## [16] pkgdown_2.0.3.9000      textshaping_0.3.6       desc_1.4.1              ## [19] stringr_1.4.0           igraph_1.3.1            RCurl_1.98-1.6          ## [22] DelayedArray_0.23.0     compiler_4.2.0          xfun_0.31               ## [25] pkgconfig_2.0.3         systemfonts_1.0.4       htmltools_0.5.2         ## [28] GenomeInfoDbData_1.2.8  bookdown_0.26           codetools_0.2-18        ## [31] MASS_7.3-57             bitops_1.0-7            grid_4.2.0              ## [34] jsonlite_1.8.0          AnnotationFilter_1.21.0 magrittr_2.0.3          ## [37] MsCoreUtils_1.9.0       ncdf4_1.19              cli_3.3.0               ## [40] stringi_1.7.6           cachem_1.0.6            XVector_0.37.0          ## [43] fs_1.5.2                bslib_0.3.1             ragg_1.2.2              ## [46] tools_4.2.0             purrr_0.3.4             parallel_4.2.0          ## [49] fastmap_1.1.0           yaml_2.3.5              clue_0.3-60             ## [52] cluster_2.1.3           BiocManager_1.30.18     memoise_2.0.1           ## [55] knitr_1.39              sass_0.4.1"},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Witting. Author. Johannes Rainer. Author, maintainer. Andrea Vicini. Author. Carolin Huber. Author.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J, Vicini , Salzer L, Stanstrup J, Badia JM, Neumann S, Stravs MA, Verri Hernandes V, Gatto L, Gibb S Wittin M. Modular Expandable Ecosystem Metabolomics Data Annotation R Metabolites 2022, 12, 173. https://doi.org/10.3390/metabo12020173","code":"@Article{,   title = {A Modular and Expandable Ecosystem for Metabolomics Data Annotation in R},   author = {Johannes Rainer and Andrea Vicini and Liesa Salzer and Jan Stanstrup and Josep M. Badia and Steffen Neumann and Michael A. Stravs and Vinicius {Verri Hernandes} and Laurent Gatto and Sebastian Gibb and Michael Witting},   journal = {Metabolites},   year = {2022},   doi = {10.3390/metabo12020173},   url = {https://www.mdpi.com/2218-1989/12/2/173},   volume = {12},   pages = {173}, }"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"metaboannotation","dir":"","previous_headings":"","what":"Utilities for Annotation of Metabolomics Data","title":"Utilities for Annotation of Metabolomics Data","text":"High level functions assist annotation (metabolomics) data sets. include functions perform simple tentative annotations based mass matching also functions consider m/z retention times annotation LC-MS features given respective reference values available. addition, function provides high-level functions simplify matching LC-MS/MS spectra spectral libraries objects functionality represent manage matched data.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Utilities for Annotation of Metabolomics Data","text":"Contributions generally welcome, follow contribution guidelines. Also, please check coding style guidelines RforMassSpectrometry vignette.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"authors-and-contributors","dir":"","previous_headings":"","what":"Authors and Contributors","title":"Utilities for Annotation of Metabolomics Data","text":"Andrea Vicini Michael Witting Johannes Rainer Carolin Huber","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching MS Spectra against a reference — CompareSpectraParam","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"matchSpectra query target Spectra object matches spectra query spectra target reports matches similarity passes THRESHFUN condition. parameters matching can specified one param objects listed : CompareSpectraParam: generic parameter object allowing set settings compareSpectra() call used perform similarity calculation. includes MAPFUN FUN defining peak-mapping similarity calculation functions ppm tolerance define acceptable difference m/z values compared peaks. Additional parameters compareSpectra call can passed along .... See help Spectra() information parameters. Parameters requirePrecursor (default TRUE) requirePrecursorPeak (default FALSE) allow pre-filter target spectra prior actual similarity calculation individual query spectrum. Target spectra can also pre-filtered based retention time parameter toleranceRt set value different default toleranceRt = Inf. target spectra retention time within query's retention time +/- (toleranceRt + percentRt% query's retention time) considered. Note ppm tolerance single value accepted, toleranceRt percentRt can also length equal number query spectra hence allowing define different rt boundaries query spectrum. pre-filters can considerably improve performance, noted matches found query target spectra missing values considered variable (precursor m/z retention time). target spectra without retention times (Spectra public reference database MassBank) default toleranceRt = Inf thus used. Finally, parameter THRESHFUN allows define function applied similarity scores define matches report. See details. MatchForwardReverseParam: performs spectra matching CompareSpectraParam reports, similar MS-DIAL, also reverse similarity score presence ratio. detail, matching query spectra target spectra performed considering peaks query peaks target (reference) spectrum (.e. forward matching using outer join-based peak matching strategy). matching spectra also reverse similarity calculated considering peaks present target (reference) spectrum (.e. using right join-based peak matching). reported spectra variable \"reverse_score\". addition, ratio number matched peaks total number peaks target (reference) spectra reported presence ratio (spectra variable \"presence_ratio\") total number matched peaks \"matched_peaks_count\". See examples details. Parameter THRESHFUN_REVERSE allows define additional threshold function filter matches. THRESHFUN_REVERSE defined matches spectra similarity fulfilling THRESHFUN THRESHFUN_REVERSE returned. default THRESHFUN_REVERSE = NULL matches passing THRESHFUN reported.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"","code":"CompareSpectraParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   toleranceRt = Inf,   percentRt = 0,   ... )  MatchForwardReverseParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   THRESHFUN_REVERSE = NULL,   toleranceRt = Inf,   percentRt = 0,   ... )  # S4 method for Spectra,Spectra,CompareSpectraParam matchSpectra(query, target, param, BPPARAM = BiocParallel::SerialParam())  # S4 method for Spectra,Spectra,MatchForwardReverseParam matchSpectra(query, target, param, BPPARAM = BiocParallel::SerialParam())"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"MAPFUN function used map peaks compared spectra. Defaults CompareSpectraParam joinPeaks(). See compareSpectra() details. tolerance numeric(1) absolute maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. ppm numeric(1) relative, m/z-dependent, maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. FUN function used calculate similarity spectra. Defaults CompareSpectraParam MsCoreUtils::ndotproduct(). See MsCoreUtils::ndotproduct() details. requirePrecursor logical(1) whether target spectra considered similarity calculation precursor m/z matches precursor m/z query spectrum (considering also ppm tolerance). requirePrecursor = TRUE (default) function complete much faster, find hits target (query spectra) missing precursor m/z. suggested check first availability precursor m/z target query. requirePrecursorPeak logical(1) whether target spectra considered spectra similarity calculation peak m/z matching precursor m/z query spectrum. Defaults requirePrecursorPeak = FALSE. suggested check first availability precursor m/z query, match reported query spectra missing precursor m/z. THRESHFUN function applied similarity score define target spectra considered matching. Defaults THRESHFUN = function(x) (x >= 0.7) hence selects target spectra matching query spectrum similarity higher equal 0.7. function takes numeric vector similarity scores comparison query spectrum target spectra (returned compareSpectra()) input returns logical vector (dimensions similarity scores) integer matches supported. toleranceRt numeric length 1 equal number query spectra defining maximal accepted (absolute) difference retention time query target spectra. default (toleranceRt = Inf) retention time-based filter considered. See help CompareSpectraParam information. percentRt numeric length 1 equal number query spectra defining maximal accepted relative difference retention time query target spectra expressed percentage query rt. percentRt = 10, similarities defined query spectrum target spectra retention time within query rt +/- 10% query. default (toleranceRt = Inf) retention time-based filter considered. Thus, consider percentRt parameter, toleranceRt set value different . See help CompareSpectraParam information. ... CompareSpectraParam: additional parameters passed along compareSpectra() call. THRESHFUN_REVERSE MatchForwardReverseParam: optional additional thresholding function filter results reverse score. specified format THRESHFUN expected. query matchSpectra: Spectra object query spectra. target matchSpectra: Spectra object target (reference) spectra compare query . param matchSpectra: parameter object (CompareSpectraParam) defining settings matching. BPPARAM matchSpectra: parallel processing setup (see BiocParallel package information). Parallel processing disabled default.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"matchSpectra returns MatchedSpectra() object. Constructor functions return instance class.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"Johannes Rainer, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"","code":"library(Spectra) #> Loading required package: S4Vectors #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table, #>     tapply, union, unique, unsplit, which.max, which.min #>  #> Attaching package: ‘S4Vectors’ #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: BiocParallel #> Loading required package: ProtGenerics #>  #> Attaching package: ‘ProtGenerics’ #> The following object is masked from ‘package:MetaboAnnotation’: #>  #>     addProcessing #> The following object is masked from ‘package:stats’: #>  #>     smooth #>  #> Attaching package: ‘Spectra’ #> The following object is masked from ‘package:ProtGenerics’: #>  #>     addProcessing library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L)  ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)]  ## Load a small example MassBank data set load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\"))  ## Match spectra with the default similarity score (normalized dot product) csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, csp)  mtches #> Object of class MatchedSpectra  #> Total number of matches: 16  #> Number of query objects: 13 (5 matched) #> Number of target objects: 100 (11 matched)  ## Are there any matching spectra for the first query spectrum? mtches[1] #> Object of class MatchedSpectra  #> Total number of matches: 0  #> Number of query objects: 1 (0 matched) #> Number of target objects: 100 (0 matched) ## No  ## And for the second query spectrum? mtches[2] #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 1 (1 matched) #> Number of target objects: 100 (4 matched) ## The second query spectrum matches 4 target spectra. The scores for these ## matches are: mtches[2]$score #> [1] 0.7869556 0.8855473 0.7234894 0.7219942  ## To access the score for the full data set mtches$score #>  [1]        NA 0.7869556 0.8855473 0.7234894 0.7219942        NA 0.7769746 #>  [8] 0.7577286        NA 0.7433718 0.7019807 0.7081274        NA 0.7320465 #> [15] 0.8106258 0.7290458 0.8168876 0.7247800 0.7412586 0.7198787        NA #> [22]        NA        NA        NA  ## Below we use a THRESHFUN that returns for each query spectrum the (first) ## best matching target spectrum. csp <- CompareSpectraParam(requirePrecursor = FALSE, ppm = 10,     THRESHFUN = function(x) which.max(x)) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 13  #> Number of query objects: 13 (13 matched) #> Number of target objects: 100 (10 matched)  ## Each of the query spectra is matched to one target spectrum length(mtches) #> [1] 13 matches(mtches) #>    query_idx target_idx        score #> 1          1          1 0.000000e+00 #> 2          2         73 8.855473e-01 #> 3          3          2 6.313687e-01 #> 4          4         44 7.769746e-01 #> 5          5         74 1.772117e-05 #> 6          6          2 7.433718e-01 #> 7          7          5 1.906998e-03 #> 8          8         53 8.168876e-01 #> 9          9         44 7.412586e-01 #> 10        10         86 4.085289e-04 #> 11        11         53 4.323403e-01 #> 12        12         47 3.469648e-03 #> 13        13         71 7.612480e-06  ## Match spectra considering also measured retention times. This requires ## that both query and target spectra have non-missing retention times. rtime(pest_ms2) #>  [1] 361.651 361.741 377.609 377.699 378.120 378.539 378.779 378.869 378.959 #> [10] 379.379 380.059 380.609 381.029 rtime(minimb) #>   [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA  ## Target spectra don't have retention times. Below we artificially set ## retention times to show how an additional retention time filter would ## work. rtime(minimb) <- rep(361, length(minimb))  ## Matching spectra requiring a matching precursor m/z and the difference ## of retention times between query and target spectra to be <= 2 seconds. csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10,     toleranceRt = 2) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 13 (1 matched) #> Number of target objects: 100 (4 matched) matches(mtches) #>   query_idx target_idx     score #> 1         2         70 0.7869556 #> 2         2         73 0.8855473 #> 3         2         75 0.7234894 #> 4         2         76 0.7219942  ## See the package vignette for details, descriptions and more examples."},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of generic objects matches — addMatches","title":"Representation of generic objects matches — addMatches","text":"Matches query target generic objects can represented Matched object. default, data accessors work left joins query target object, .e. values returned query object eventual duplicated entries (values) query object matches one target object. See also Creation subsetting well Extracting data sections details information. Matched object allows represent matches one-dimensional query target objects (e.g. numeric list), two-dimensional objects (data.frame matrix) complex structures SummarizedExperiments QFeatures. Combinations different data types also supported. Matches represented elements one-dimensional objects, rows two-dimensional objects (including SummarizedExperiment QFeatures). QFeatures() objects matches one assays within object supported.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of generic objects matches — addMatches","text":"","code":"addMatches(object, ...)  filterMatches(object, param, ...)  matchedData(object, ...)  Matched(   query = list(),   target = list(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score =     numeric()),   queryAssay = character(),   targetAssay = character(),   metadata = list() )  # S4 method for Matched length(x)  # S4 method for Matched show(object)  # S4 method for Matched,ANY,ANY,ANY [(x, i, j, ..., drop = FALSE)  matches(object)  target(object)  query(object)  whichTarget(object)  whichQuery(object)  # S4 method for Matched $(x, name)  # S4 method for Matched colnames(x)  # S4 method for Matched matchedData(object, columns = colnames(object), ...)  pruneTarget(object)  # S4 method for Matched,missing filterMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE,   ... )  SelectMatchesParam(   queryValue = numeric(),   targetValue = numeric(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE )  TopRankedMatchesParam(n = 1L, decreasing = FALSE)  # S4 method for Matched,SelectMatchesParam filterMatches(object, param, ...)  # S4 method for Matched,TopRankedMatchesParam filterMatches(object, param, ...)  # S4 method for Matched addMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   score = rep(NA_real_, length(queryValue)),   isIndex = FALSE )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of generic objects matches — addMatches","text":"object Matched object. ... additional parameters. param filterMatches: parameter object select customize filtering procedure. query object query elements. target object elements query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target objects. queryAssay character needs specified query QFeatures. case, queryAssay expected name one assays query (one matching performed). targetAssay character needs specified target QFeatures. case, targetAssay expected name one assays target (one matching performed). metadata list optional additional metadata. x Matched object. integer logical defining query elements keep. j [: ignored. drop [: ignored. name $: name column (variable) extract. columns matchedData: character vector column names variables extracted. queryValue SelectMatchesParam: vector values search query (query 1-dimensional) column queryColname query (query 2-dimensional). addMatches: either index query value column queryColname query defining (together targetValue) pair query target elements match manually added. Lengths queryValue targetValue match. targetValue SelectMatchesParam: vector values search target (target 1-dimensional) column targetColname target (target 2-dimensional). addMatches: either index target value column targetColname target defining (together queryValue) pair query target elements match manually added. Lengths queryValue targetValue match. queryColname SelectMatchesParam: query 2-dimensional represents column query elements queryValue compared. targetColname SelectMatchesParam: query 2-dimensional represents column target elements targetValue compared. index SelectMatchesParam: indices matches keep (keep = TRUE) drop (keep = FALSE). keep SelectMatchesParam: logical. keep = TRUE matches kept, keep = FALSE removed. n TopRankedMatchesParam: integer(1) number best ranked matches keep query element. decreasing TopRankedMatchesParam: logical(1) whether scores ordered increasing decreasing. Defaults decreasing = FALSE. score addMatches: numeric (length queryValue) data.frame (number rows queryValue) specifying scores matches add. specified, NA used score. isIndex addMatches: specifies queryValue targetValue expected vectors indices.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of generic objects matches — addMatches","text":"See individual method description details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"creation-and-subsetting","dir":"Reference","previous_headings":"","what":"Creation and subsetting","title":"Representation of generic objects matches — addMatches","text":"Matched object returned result matchValues() function. Alternatively, Matched objects can also created Matched function providing query target objects well matches data.frame two columns integer indices defining elements query match element target. [ subset object selecting query object elements keep parameter . resulting object contain matches selected query elements. target object default returned -. addMatches: add new matches existing object. Parameters queryValue targetValue allow define element(s) query target considered matching. isIndex = TRUE, queryValue targetValue considered integer indices identifying matching elements query target, respectively. Alternatively (isIndex = FALSE) queryValue targetValue can elements columns queryColname targetColname can used identify matching elements. Note case first matching pair added. Parameter score allows provide score match. can numeric score data.frame additional information manually added matches. cases length (number rows) match length queryValue. See examples information. filterMatches: filter matches Matched object using different approaches depending class param: SelectMatchesParam: keeps removes (respectively parameter keep = TRUE keep = FALSE) matches corresponding certain indices values query target. queryValue targetValue provided, matches value pairs kept removed. Parameter indexallows filter matches providing index [matches()] matrix. Note thatfilterMatchesremoves matches [matches()] matrix theMatchedobject thus alter thequeryortarget` object. See examples information. TopRankedMatchesParam: query element matches ranked according score n best kept (n larger number matches given query element matches returned). ranking (ordering) R's rank function used absolute values scores (variable \"score\"), thus, smaller score values (representing e.g. smaller differences expected observed m/z values) considered better. setting parameter decreasing = TRUE matches can ranked decreasing order (.e. higher scores ranked higher thus selected). besides variable \"score\" also variable \"score_rt\" available Matched object (case Matched object returned matchValues() param objects involving retention time comparison), ordering matches based product ranks two variables (ranking retention time differences performed absolute value \"score_rt\"). Thus, matches small (, depending parameter decreasing, large) values \"score\" \"score_rt\" returned. pruneTarget cleans object removing non-matched target elements.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of generic objects matches — addMatches","text":"$ extracts single variable Matched x. variables can extracted can listed using colnames(x). variables can belong query, target related matches (e.g. score match). query (target) object two dimensional, columns can extracted (prefix \"target_\" used columns target object) otherwise query (target) single dimension (e.g. list character) whole object can extracted x$query (x$target). precisely, query (target) SummarizedExperiment columns rowData(query) (rowData(target)) extracted; query (target) QFeatures() columns rowData assay specified queryAssay (targetAssay) slot extracted. matching scores available variable \"score\". Similar left join query target elements, function returns value query element, eventual duplicated values query elements matching one target element. variables target data.frame extracted, NA reported entries corresponding query elements match target element. See examples details. length returns number query elements. matchedData allows extract multiple variables contained Matched object DataFrame. Parameter columns allows define columns (variables) returned (defaults columns = colnames(object)). single column returned DataFrame constructed way $. , like $, function performs left join variables query target objects returning values query elements (eventually returning duplicated elements query elements matching multiple target elements) values target elements matched respective query elements (NA target element matched query element). matches returns data.frame actual matching information columns \"query_idx\" (index element query), \"target_idx\" (index element target) \"score\" (score match) eventual additional columns. target returns target object. query returns query object. whichTarget returns integer indices elements target match least one element query. whichQuery returns integer indices elements query match least one element target.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of generic objects matches — addMatches","text":"Andrea Vicini, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of generic objects matches — addMatches","text":"","code":"## Creating a `Matched` object. q1 <- data.frame(col1 = 1:5, col2 = 6:10) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between query row 1 with target row 2 and, query row 2 ## with target rows 2,3,4 and query row 5 with target row 5. mo <- Matched(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                  target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class Matched  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from query object . mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to query ## elements (rows) matched to multiple rows of the target object). The ## value of `col1` is returned for each element (row) in the query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one query ## row are returned and an NA is reported for query rows without matching ## target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\",                                    \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>          col1      col2 target_col1 target_col2 #>     <integer> <integer>   <integer>   <integer> #> 1           1         6          12          18 #> 2           2         7          12          18 #> 2.1         2         7          13          19 #> 2.2         2         7          14          20 #> 3           3         8          NA          NA #> 4           4         9          NA          NA #> 5           5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The example matched object contains all query and all target ## elements (rows). Below we subset the object keeping only query rows that ## are matched to at least one target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one query row mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4  ######## ## Creating a `Matched` object with a `data.frame` for `query` and a `vector` ## for `target`. The matches are specified in the same way as the example ## before.  q1 <- data.frame(col1 = 1:5, col2 = 6:10) t2 <- 11:16 mo <- Matched(q1, t2, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),     target_idx = c(2L, 2L, 3L, 4L, 5L), score = seq(0.5, 0.9, by = 0.1)))  ## *target* is a simple vector and has thus no columns. The matched values ## from target, if it does not have dimensions and hence column names, can ## be retrieved with `$target` mo$target #> [1] 12 12 13 14 NA NA 15  ## Note that in this case \"target\" is returned by the function `colnames` colnames(mo) #> [1] \"col1\"   \"col2\"   \"target\" \"score\"   ## As before, we can extract all data as a `DataFrame` res <- matchedData(mo) res #> DataFrame with 7 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9  ## Note that the columns of the obtained `DataFrame` are the same as the ## corresponding vectors obtained with `$` res$col1 #> [1] 1 2 2 2 3 4 5 res$target #> [1] 12 12 13 14 NA NA 15  ## Also subsetting and pruning works in the same way as the example above.  mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both object contain however still the full target object: length(target(mo)) #> [1] 6 length(target(mo_sub)) #> [1] 6  ## Reducing the target elements to only those that match at least one query ## row mo_sub <- pruneTarget(mo_sub) length(target(mo_sub)) #> [1] 4  ######## ## Filtering `Matched` with `filterMatches`  ## Inspecting the matches in `mo`: mo$col1 #> [1] 1 2 2 2 3 4 5 mo$target #> [1] 12 12 13 14 NA NA 15  ## We have thus target *12* matched to both query elements with values 1 and ## 2, and query element 2 is matching 3 target elements. Let's assume we want ## to resolve this multiple mappings to keep from them only the match between ## query 1 (column `\"col1\"` containing value `1`) with target 1 (value `12`) ## and query 2 (column `\"col1\"` containing value `2`) with target 2 (value ## `13`). In addition we also want to keep query element 5 (value `5` in ## column `\"col1\"`) with the target with value `15`: mo_sub <- filterMatches(mo,     SelectMatchesParam(queryValue = c(1, 2, 5), queryColname = \"col1\",                        targetValue = c(12, 13, 15))) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     13       0.7 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ## Alternatively to specifying the matches to filter with `queryValue` and ## `targetValue` it is also possible to specify directly the index of the ## match(es) in the `matches` `data.frame`: matches(mo) #>   query_idx target_idx score #> 1         1          2   0.5 #> 2         2          2   0.6 #> 3         2          3   0.7 #> 4         2          4   0.8 #> 5         5          5   0.9  ## To keep only matches like in the example above we could use: mo_sub <- filterMatches(mo, SelectMatchesParam(index = c(1, 3, 5))) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     13       0.7 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ## Note also that, instead of keeping the specified matches, it would be ## possible to remove them by setting `keep = FALSE`. Below we remove ## selected matches from the object: mo_sub <- filterMatches(mo,     SelectMatchesParam(queryValue = c(2, 2), queryColname = \"col1\",                        targetValue = c(12, 14), keep = FALSE)) mo_sub$col1 #> [1] 1 2 3 4 5 mo_sub$target #> [1] 12 13 NA NA 15  ## As alternative to *manually* selecting matches it is also possible to ## filter matches keeping only the *best matches* using the ## `TopRankedMatchesParam`. This will rank matches for each query based on ## their *score* value and select the best *n* matches with lowest score ## values (i.e. smallest difference in m/z values). mo_sub <- filterMatches(mo, TopRankedMatchesParam(n = 1L)) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     12       0.6 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ######## ## Adding matches using `addMatches`  ## `addMatches` allows to manually add matches. Below we add a new match ## between the `query` element with a value of `1` in column `\"col1\"` and ## the target element with a value of `15`. Parameter `score` allows to ## assign a score value to the match. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = 1.40) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 1.1         1         6     15       1.4 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9 ## Matches are always sorted by `query`, thus, the new match is listed as ## second match.  ## Alternatively, we can also provide a `data.frame` with parameter `score` ## which enables us to add additional information to the added match. Below ## we define the score and an additional column specifying that this match ## was added manually. This information will then also be available in the ## `matchedData`. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = data.frame(score = 5, manual = TRUE)) matchedData(mo_add) #> DataFrame with 8 rows and 5 columns #>          col1      col2 target     score    manual #>     <integer> <integer> <AsIs> <numeric> <logical> #> 1           1         6     12       0.5        NA #> 1.1         1         6     15       5.0      TRUE #> 2           2         7     12       0.6        NA #> 2.1         2         7     13       0.7        NA #> 2.2         2         7     14       0.8        NA #> 3           3         8     NA        NA        NA #> 4           4         9     NA        NA        NA #> 5           5        10     15       0.9        NA  ## The match will get a score of NA if we're not providing any score. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 1.1         1         6     15        NA #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9  ## Creating a `Matched` object with a `SummarizedExperiment` for `query` and ## a `vector` for `target`. The matches are specified in the same way as ## the example before. library(SummarizedExperiment) #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians q1 <- SummarizedExperiment(   assays = data.frame(matrix(NA, 5, 2)),   rowData = data.frame(col1 = 1:5, col2 = 6:10),   colData = data.frame(cD1 = c(NA, NA), cD2 = c(NA, NA))) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between row 1 in rowData(q1) with target row 2 and, ## rowData(q1) row 2 with target rows 2,3,4 and rowData(q1) row 5 with target ## row 5. mo <- Matched(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                 target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class Matched  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from rowData(q1). mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to rows of ## rowData(q1) matched to multiple rows of the target data.frame t1. The ## value of `col1` is returned for each row in the rowData of query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one row in ## rowData of query are returned and an NA is reported for those without ## matching target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\",                                   \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>        col1      col2 target_col1 target_col2 #>   <integer> <integer>   <integer>   <integer> #> 1         1         6          12          18 #> 2         2         7          12          18 #> 2         2         7          13          19 #> 2         2         7          14          20 #> 3         3         8          NA          NA #> 4         4         9          NA          NA #> 5         5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The example `Matched` object contains all rows in the ## `rowData` of the `SummarizedExperiment` and all target rows. Below we ## subset the object keeping only rows that are matched to at least one ## target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now a `SummarizedExperiment` with only 3 rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains a `SummarizedExperiment` with all 5 ## rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one in the `rowData` of query mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of Spectra matches — MatchedSpectra","title":"Representation of Spectra matches — MatchedSpectra","text":"Matches query target spectra can represented MatchedSpectra object. Functions like matchSpectra() function return type object. default, data accessors work left joins query target spectra, .e. values returned query spectrum eventual duplicated entries (values) query spectrum matches one target spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"MatchedSpectra(   query = Spectra(),   target = Spectra(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score =     numeric()) )  # S4 method for MatchedSpectra spectraVariables(object)  # S4 method for MatchedSpectra colnames(x)  # S4 method for MatchedSpectra $(x, name)  # S4 method for MatchedSpectra spectraData(object, columns = spectraVariables(object))  # S4 method for MatchedSpectra matchedData(object, columns = spectraVariables(object), ...)  # S4 method for MatchedSpectra addProcessing(object, FUN, ..., spectraVariables = character())  # S4 method for MatchedSpectra plotSpectraMirror(x, xlab = \"m/z\", ylab = \"intensity\", main = \"\", ...)  # S4 method for MatchedSpectra,MsBackend setBackend(object, backend, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of Spectra matches — MatchedSpectra","text":"query Spectra query spectra. target Spectra spectra query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target Spectra. object MatchedSpectra object. x MatchedSpectra object. name $: name spectra variable extract. columns spectraData: character vector spectra variable names extracted. ... addProcessing: additional parameters function FUN. plotSpectraMirror: additional parameters passed plotting functions. FUN addProcessing: function applied peak matrix spectrum object. See Spectra() details. spectraVariables addProcessing: character additional spectra variables passed along function defined FUN. See Spectra() details. xlab plotSpectraMirror: label x-axis. ylab plotSpectraMirror: label y-axis. main plotSpectraMirror: optional title plot. backend setBackend: instance object extending MsBackend. See help setBackend Spectra() details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of Spectra matches — MatchedSpectra","text":"See individual method desciption details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"creation-and-subsetting","dir":"Reference","previous_headings":"","what":"Creation and subsetting","title":"Representation of Spectra matches — MatchedSpectra","text":"MatchedSpectra objects can created MatchedSpectra function providing query target Spectra well data.frame [ subset MatchedSpectra selecting query spectra keep parameter . target spectra default returned -. pruneTarget cleans MatchedSpectra object removing non-matched target spectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of Spectra matches — MatchedSpectra","text":"$ extracts single spectra variable MatchedSpectra x. Use spectraVariables get available spectra variables. Prefix \"target_\" used spectra variables target Spectra. matching scores available spectra variable \"score\". Similar left join query target spectra, function returns value query spectrum eventual duplicated values query spectra matching one target spectrum. spectra variables target spectra extracted, NA reported query spectra match target spectra. See examples details. length returns number query spectra. matchedData spectraData . spectraData returns spectra variables query /target Spectra DataFrame. Parameter columns allows define variables returned (defaults columns = spectraVariables(object)), spectra variable names target spectra need prefixed target_ (e.g. target_msLevel get MS level target spectra). score matching function returned spectra variable \"score\". Similar $, function performs left join spectra variables query target spectra returning values query spectra (eventually returning duplicated elements query spectra matching multiple target spectra) values target spectra matched respective query spectra. See help $ examples details. spectraVariables returns available spectra variables query target spectra. prefix \"target_\" used label spectra variables target spectra (e.g. name spectra variable MS level target spectra called \"target_msLevel\"). target returns target Spectra. query returns query Spectra. whichTarget returns integer indices spectra target match least spectrum query. whichQuery returns integer indices spectra query match least spectrum target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"data-manipulation-and-plotting","dir":"Reference","previous_headings":"","what":"Data manipulation and plotting","title":"Representation of Spectra matches — MatchedSpectra","text":"addProcessing: add processing step query target Spectra object. Additional parameters FUN can passed via .... See addProcessing documentation Spectra() information. plotSpectraMirror: creates mirror plot query matching target spectrum. Can applied MatchedSpectra single query spectrum. Additional plotting parameters can passed .... setBackend: allows change backend query target Spectra() object. function return MatchedSpectra object query target Spectra changed specified backend, can backend extending MsBackend.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of Spectra matches — MatchedSpectra","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"## Creating a dummy MatchedSpectra object. library(Spectra) df1 <- DataFrame(     msLevel = 2L, rtime = 1:10,     spectrum_id = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\")) df2 <- DataFrame(     msLevel = 2L, rtime = rep(1:10, 20),     spectrum_id = rep(c(\"A\", \"B\", \"C\", \"D\", \"E\"), 20)) sp1 <- Spectra(df1) sp2 <- Spectra(df2) ## Define matches between query spectrum 1 with target spectra 2 and 5, ## query spectrum 2 with target spectrum 2 and query spectrum 4 with target ## spectra 8, 12 and 15. ms <- MatchedSpectra(     sp1, sp2, matches = data.frame(query_idx = c(1L, 1L, 2L, 4L, 4L, 4L),                                    target_idx = c(2L, 5L, 2L, 8L, 12L, 15L),                                    score = 1:6))  ## Which of the query spectra match at least one target spectrum? whichQuery(ms) #> [1] 1 2 4  ## Extracting spectra variables: accessor methods for spectra variables act ## as \"left joins\", i.e. they return a value for each query spectrum, with ## eventually duplicated elements if one query spectrum matches more than ## one target spectrum.  ## Which target spectrum matches at least one query spectrum? whichTarget(ms) #> [1]  2  5  8 12 15  ## Extracting the retention times of the query spectra. ms$rtime #>  [1]  1  1  2  3  4  4  4  5  6  7  8  9 10  ## We have duplicated retention times for query spectrum 1 (matches 2 target ## spectra) and 4 (matches 3 target spectra). The retention time is returned ## for each query spectrum.  ## Extracting retention times of the target spectra. Note that only retention ## times for target spectra matching at least one query spectrum are returned ## and an NA is reported for query spectra without matching target spectrum. ms$target_rtime #>  [1]  2  5  2 NA  8  2  5 NA NA NA NA NA NA  ## The first query spectrum matches target spectra 2 and 5, thus their ## retention times are returned as well as the retention time of the second ## target spectrum that matches also query spectrum 2. The 3rd query spectrum ## does match any target spectrum, thus `NA` is returned. Query spectrum 4 ## matches target spectra 8, 12, and 15, thus the next reported retention ## times are those from these 3 target spectra. None of the remaining 6 query ## spectra matches any target spectra and thus `NA` is reported for each of ## them.  ## `spectraData` can be used to extract all (or selected) spectra variables ## from the object. Same as with `$`, a left join between the specta ## variables from the query spectra and the target spectra is performed. The ## prefix `\"target_\"` is used to label the spectra variables from the target ## spectra. Below we extract selected spectra variables from the object. res <- spectraData(ms, columns = c(\"rtime\", \"spectrum_id\",     \"target_rtime\", \"target_spectrum_id\")) res #> DataFrame with 13 rows and 4 columns #>         rtime spectrum_id target_rtime target_spectrum_id #>     <integer> <character>    <integer>        <character> #> 1           1           a            2                  B #> 2           1           a            5                  E #> 3           2           b            2                  B #> 4           3           c           NA                 NA #> 5           4           d            8                  C #> ...       ...         ...          ...                ... #> 9           6           f           NA                 NA #> 10          7           g           NA                 NA #> 11          8           h           NA                 NA #> 12          9           i           NA                 NA #> 13         10           j           NA                 NA res$spectrum_id #>  [1] \"a\" \"a\" \"b\" \"c\" \"d\" \"d\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" res$target_spectrum_id #>  [1] \"B\" \"E\" \"B\" NA  \"C\" \"B\" \"E\" NA  NA  NA  NA  NA  NA   ## Again, all values for query spectra are returned and for query spectra not ## matching any target spectrum NA is reported as value for the respecive ## variable.  ## The example matched spectra object contains all query and all target ## spectra. Below we subset the object keeping only query spectra that are ## matched to at least one target spectrum. ms_sub <- ms[whichQuery(ms)]  ## ms_sub contains now only 3 query spectra: length(query(ms_sub)) #> [1] 3  ## while the original object contains all 10 query spectra: length(query(ms)) #> [1] 10  ## Both object contain however still the full target `Spectra`: length(target(ms)) #> [1] 200 length(target(ms_sub)) #> [1] 200  ## With the `pruneTarget` we can however reduce also the target spectra to ## only those that match at least one query spectrum ms_sub <- pruneTarget(ms_sub) length(target(ms_sub)) #> [1] 5"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal page for hidden aliases — hidden_aliases","title":"Internal page for hidden aliases — hidden_aliases","text":"S4 methods require documentation entry clutter index.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal page for hidden aliases — hidden_aliases","text":"applicable","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":null,"dir":"Reference","previous_headings":"","what":"Chemical Formula Matching — matchFormula","title":"Chemical Formula Matching — matchFormula","text":"matchFormula method matches chemical formulas different inputs (parameter query target). comparison formulas normalized using MetaboCoreUtils::standardizeFormula(). Inputs can either character data.frame containing column formulas. case data.frames parameter formulaColname needs used specify name column containing chemical formulas.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chemical Formula Matching — matchFormula","text":"","code":"matchFormula(query, target, ...)  # S4 method for character,character matchFormula(query, target, BPPARAM = SerialParam())  # S4 method for data.frameOrSimilar,data.frameOrSimilar matchFormula(   query,   target,   formulaColname = c(\"formula\", \"formula\"),   BPPARAM = SerialParam() )  # S4 method for character,data.frameOrSimilar matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )  # S4 method for data.frameOrSimilar,character matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chemical Formula Matching — matchFormula","text":"query character data.frame chemical formulas search. target character data.frame chemical formulas compare . ... currently ignored BPPARAM parallel processing setup. See BiocParallel::bpparam() details. formulaColname character name column containing chemical formulas. Can length 1 query target data.frames name column chemical formulas . different columns used, formulaColname[1] can used define column name query formulaColname[2] one target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chemical Formula Matching — matchFormula","text":"Matched object representing result.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Chemical Formula Matching — matchFormula","text":"Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chemical Formula Matching — matchFormula","text":"","code":"## input formula query <- c(\"H12C6O6\", \"C11H12O2\", \"HN3\") target <- c(\"HCl\", \"C2H4O\", \"C6H12O6\")  query_df <- data.frame(     formula = c(\"H12C6O6\", \"C11H12O2\", \"HN3\"),     name = c(\"A\", \"B\", \"C\") ) target_df <- data.frame(     formula = c(\"HCl\", \"C2H4O\", \"C6H12O6\"),     name = c(\"D\", \"E\", \"F\") )  ## character vs character matches <- matchFormula(query, target) matchedData(matches) #> DataFrame with 3 rows and 3 columns #>            query  target     score #>           <AsIs>  <AsIs> <numeric> #> C6H12O6  H12C6O6 C6H12O6         1 #> NA      C11H12O2      NA        NA #> NA.1         HN3      NA        NA  ## data.frame vs data.frame matches <- matchFormula(query_df, target_df) matchedData(matches) #> DataFrame with 3 rows and 5 columns #>       formula        name target_formula target_name     score #>   <character> <character>    <character> <character> <numeric> #> 1     H12C6O6           A        C6H12O6           F         1 #> 2    C11H12O2           B             NA          NA        NA #> 3         HN3           C             NA          NA        NA ## data.frame vs character matches <- matchFormula(query_df, target) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>       formula        name  target     score #>   <character> <character>  <AsIs> <numeric> #> 1     H12C6O6           A C6H12O6         1 #> 2    C11H12O2           B      NA        NA #> 3         HN3           C      NA        NA ## character vs data.frame matches <- matchFormula(query, target_df) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>         query target_formula target_name     score #>        <AsIs>    <character> <character> <numeric> #> 3     H12C6O6        C6H12O6           F         1 #> NA   C11H12O2             NA          NA        NA #> NA.1      HN3             NA          NA        NA"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral matching — matchSpectra","title":"Spectral matching — matchSpectra","text":"matchSpectra method matches (compares) spectra query target based settings specified param returns result MatchedSpectra object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral matching — matchSpectra","text":"","code":"matchSpectra(query, target, param, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral matching — matchSpectra","text":"query Spectra object (experimental) spectra. target spectral data compare . Can another Spectra. param parameter object containing settings matching (e.g. eventual prefiltering settings, cut-value similarity spectra considered matching etc). ... optional parameters.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral matching — matchSpectra","text":"MatchedSpectra object spectra matching results.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spectral matching — matchSpectra","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching of numeric values — ValueParam","title":"Matching of numeric values — ValueParam","text":"matchValues method matches elements query target using different matching approaches depending parameter param. Generally, query expected contain MS experimental values (m/z possibly retention time) target reference values. query target can numeric, two dimensional array (data.frame, matrix DataFrame), SummarizedExperiment QFeatures. SummarizedExperiment, information matching expected object's rowData. QFeatures matching performed values present rowData one object's assays (needs specified assayQuery parameter - QFeatures used target name assay needs specified parameter assayTarget). matchMz alias matchValues allow backward compatibility. Available param objects corresponding matching approaches : ValueParam: generic matching values query target given acceptable differences expressed ppm tolerance. query target numeric, parameter valueColname used specify name column contains values matched. function returns Matched() object. MzParam: match query m/z values reference compounds also m/z known. Matching performed similarly ValueParam . query target numeric, column name containing values compared must defined matchValues' parameter mzColname, defaults \"mz\". MzParam parameters tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values. MzRtParam: match m/z retention time values query target. Parameters mzColname rtColname matchValues function allow define columns query target containing values (defaulting c(\"mz\", \"mz\") c(\"rt\", \"rt\"), respectively). MzRtParam parameters tolerance ppm meaning MzParam; MzRtParam parameter toleranceRt allows specify maximal acceptable difference query target retention time values. Mass2MzParam: match m/z values reference compounds (exact) mass known. matching, m/z values calculated compounds masses target table using adducts specified via Mass2MzParam adducts parameter (defaults adducts = \"[M+H]+\"). conversion adduct masses m/z values, matching performed similarly MzParam (.e. parameters ppm tolerance can used). query numeric, parameter mzColname matchValues can used specify column containing query's m/z values (defaults \"mz\"). target numeric, parameter massColname can used define column containing reference compound's masses (defaults \"exactmass\"). Mass2MzRtParam: match m/z retention time values reference compounds (exact) mass retention time known. matching, exact masses target converted m/z values Mass2MzParam. Matching performed similarly MzRtParam, .e. m/z retention times entities compared. matchValues' parameters mzColname, rtColname massColname columns containing m/z values (query), retention time values (query target) exact masses (target) can specified. Mz2MassParam: input values query target expected m/z values matching performed exact masses calculated (based provided adduct definitions). detail, m/z values query first converted masses mz2mass() function based adducts defined queryAdducts (defaults \"[M+H]+\"). done m/z values target (adducts can defined targetAdducts defaults \"[M-H-]\"). Matching performed converted values similarly ValueParam. queryortargetare numeric, column containing m/z values can specified withmatchValues' parameter mzColname(defaults \"mz\"`). Mz2MassRtParam: Mz2MassParam additional comparison retention times query target. Parameters rtColname mzColname matchValues allow specify columns contain retention times m/z values, respectively.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching of numeric values — ValueParam","text":"","code":"ValueParam(tolerance = 0, ppm = 5)  MzParam(tolerance = 0, ppm = 5)  Mass2MzParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5)  Mass2MzRtParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5, toleranceRt = 0)  MzRtParam(tolerance = 0, ppm = 0, toleranceRt = 0)  Mz2MassParam(   queryAdducts = c(\"[M+H]+\"),   targetAdducts = c(\"[M-H]-\"),   tolerance = 0,   ppm = 5 )  Mz2MassRtParam(   queryAdducts = c(\"[M+H]+\"),   targetAdducts = c(\"[M+H]+\"),   tolerance = 0,   ppm = 5,   toleranceRt = 0 )  matchValues(query, target, param, ...)  # S4 method for numeric,numeric,ValueParam matchValues(query, target, param)  # S4 method for numeric,data.frameOrSimilar,ValueParam matchValues(   query,   target,   param,   valueColname = character(),   targetAssay = character() )  # S4 method for data.frameOrSimilar,numeric,ValueParam matchValues(   query,   target,   param,   valueColname = character(),   queryAssay = character() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,ValueParam matchValues(   query,   target,   param,   valueColname = character(),   queryAssay = character(),   targetAssay = character() )  # S4 method for numeric,numeric,Mass2MzParam matchValues(query, target, param)  # S4 method for numeric,data.frameOrSimilar,Mass2MzParam matchValues(   query,   target,   param,   massColname = \"exactmass\",   targetAssay = character() )  # S4 method for data.frameOrSimilar,numeric,Mass2MzParam matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mass2MzParam matchValues(   query,   target,   param,   mzColname = \"mz\",   massColname = \"exactmass\",   queryAssay = character(0),   targetAssay = character(0) )  # S4 method for numeric,data.frameOrSimilar,MzParam matchValues(query, target, param, mzColname = \"mz\", targetAssay = character())  # S4 method for data.frameOrSimilar,numeric,MzParam matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for data.frameOrSimilar,data.frameOrSimilar,MzParam matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mass2MzRtParam matchValues(   query,   target,   param,   massColname = \"exactmass\",   mzColname = \"mz\",   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,MzRtParam matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for numeric,numeric,Mz2MassParam matchValues(query, target, param)  # S4 method for numeric,data.frameOrSimilar,Mz2MassParam matchValues(query, target, param, mzColname = \"mz\", targetAssay = character())  # S4 method for data.frameOrSimilar,numeric,Mz2MassParam matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mz2MassParam matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mz2MassRtParam matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching of numeric values — ValueParam","text":"tolerance param object: numeric(1) defining maximal acceptable absolute difference m/z (mass Mz2MassParam) consider matching. ppm param object: numeric(1) defining maximal acceptable m/z-dependent (mass-dependent Mz2MassParam) difference (parts-per-million) m/z values consider matching. adducts Mass2MzParam Mass2MzRtParam: either character adduct names MetaboCoreUtils::adducts() data.frame custom adduct definition. parameter used calculate m/z target compounds' masses. Custom adduct definitions can passed adduct parameter form data.frame. data.frame expected columns \"mass_add\" \"mass_multi\" defining additive multiplicative part calculation. See MetaboCoreUtils::adducts() expected format use MetaboCoreUtils::adductNames(\"positive\") MetaboCoreUtils::adductNames(\"negative\") valid adduct names. toleranceRt Mass2MzRtParam MzRtParam: numeric(1) defining maximal acceptable absolute difference retention time values consider matching. queryAdducts Mz2MassParam. Adducts used derive mass values query m/z values. expected format parameter adducts. targetAdducts Mz2MassParam. Adducts used derive mass values target m/z values. expected format parameter adducts. query feature table containing information MS1 features. Can numeric, data.frame, DataFrame, matrix, SummarizedExperiment QFeatures. expected contain m/z values can contain also variables. Matchings based m/z retention time can performed column retention times present query target. target compound table metabolites compare . expected types query. param parameter object defining matching approach containing settings approach. See description details. ... currently ignored. valueColname character specifying name column query /one targetwith desired values matching. parameter used param valueParam case must provided (unless query target numeric). can character(1) character(2) similar way mzColname. targetAssay character(1) specifying name assay provided QFeatures used matching (values assay's rowData used matching). used target instance QFeatures object. queryAssay character(1) specifying name assay provided QFeatures used matching (values assay's rowData used matching). used query instance QFeatures object. massColname character(1) name column target containing mass compounds. used param Mass2MzParam Mass2MzRtParam (target already numeric masses). Defaults massColname = \"exactmass\". mzColname character specifying name(s) column(s) query /targetwith m/z values. one among query target numeric (therefore need specify column name) query numeric param Mass2MzParam Mass2MzRtParam (therefore name column m/z needs specified query) mzColname expected character(1). query target numeric mzColname expected character(2) (character(1) last case two column names assumed ). specified assumed default name columns m/z values \"mz\". rtColname character(2) name column containing compounds retention times query name one target. can also character(1) two names . used param MzRtParam Mass2MzRtParam. Defaults rtColname = c(\"rt\", \"rt\").","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching of numeric values — ValueParam","text":"Matched object representing result. Depending param object different scores representing quality match provided. comprises absolute well relative differences (column/variables \"score\" \"ppm_error\" respectively). param Mz2MassParam, \"score\" \"ppm_error\" represent differences compared masses (calculated provided m/z values). param MzParam, MzRtParam, Mass2MzParam Mass2MzRtParam, \"score\" \"ppm_error\" represent absolute relative differences m/z values. Additionally, param either MzRtParam Mass2MzRtParamdifferences query target retention times matched element available column/variable \"score_rt\" returned Matched object. Negative values \"score\" (\"score_rt\") indicate m/z mass (retention time) query element smaller target element.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching of numeric values — ValueParam","text":"Andrea Vicini, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching of numeric values — ValueParam","text":"","code":"library(MetaboCoreUtils) ## Create a simple \"target/reference\" compound table target_df <- data.frame(    name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),    formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),    exactmass = c(204.089878, 131.094629, 131.094629) )  ## Create a \"feature\" table with m/z of features. We calculate m/z for ## certain adducts of some of the compounds in the reference table. fts <- data.frame(     feature_id = c(\"FT001\", \"FT002\", \"FT003\"),     mz = c(mass2mz(204.089878, \"[M+H]+\"),            mass2mz(131.094629, \"[M+H]+\"),            mass2mz(204.089878, \"[M+Na]+\") + 1e-6))  ## Define the parameters for the matching parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 20) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## List the available variables/columns colnames(res) #> [1] \"feature_id\"       \"mz\"               \"target_name\"      \"target_formula\"   #> [5] \"target_exactmass\" \"adduct\"           \"score\"            \"ppm_error\"         ## feature_id and mz are from the query data frame, while target_name, ## target_formula and target_exactmass are from the query object (columns ## from the target object have a prefix *target_* added to the original ## column name. Columns adduct, score and ppm_error represent the results ## of the matching: adduct the adduct/ion of the original compound for which ## the m/z matches, score the absolute difference of the query and target ## m/z and ppm_error the relative difference in m/z values.  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079  Tryptophan     C11H12N2O2          204.090 #>          adduct     score  ppm_error #>     <character> <numeric>  <numeric> #> 1        [M+H]+     0e+00 0.00000000 #> 2        [M+H]+     0e+00 0.00000000 #> 2.1      [M+H]+     0e+00 0.00000000 #> 3       [M+Na]+     1e-06 0.00440375  ## We have thus matches of FT002 to two different compounds (but with the ## same mass).  ## Individual columns can also be accessed with the $ operator: res$feature_id #> [1] \"FT001\" \"FT002\" \"FT002\" \"FT003\" res$target_name #> [1] \"Tryptophan\" \"Leucine\"    \"Isoleucine\" \"Tryptophan\" res$ppm_error #> [1] 0.000000000 0.000000000 0.000000000 0.004403752   ## We repeat the matching requiring an exact match parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 0) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079          NA             NA               NA #>          adduct     score ppm_error #>     <character> <numeric> <numeric> #> 1        [M+H]+         0         0 #> 2        [M+H]+         0         0 #> 2.1      [M+H]+         0         0 #> 3            NA        NA        NA  ## The last feature could thus not be matched to any compound.  ## At last we use also different adduct definitions. parm <- Mass2MzParam(     adducts = c(\"[M+K]+\", \"[M+Li]+\"),     tolerance = 0,     ppm = 20) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 0  #> Number of query objects: 3 (0 matched) #> Number of target objects: 3 (0 matched)  matchedData(res) #> DataFrame with 3 rows and 8 columns #>    feature_id        mz target_name target_formula target_exactmass      adduct #>   <character> <numeric> <character>    <character>        <numeric> <character> #> 1       FT001   205.097          NA             NA               NA          NA #> 2       FT002   132.102          NA             NA               NA          NA #> 3       FT003   227.079          NA             NA               NA          NA #>       score ppm_error #>   <numeric> <numeric> #> 1        NA        NA #> 2        NA        NA #> 3        NA        NA  ## No matches were found.  ## We can also match a \"feature\" table with a target data.frame taking into ## account both m/z and retention time values. target_df <- data.frame(   name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),   formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),   exactmass = c(204.089878, 131.094629, 131.094629),   rt = c(150, 140, 140) )  fts <- data.frame(   feature_id = c(\"FT001\", \"FT002\", \"FT003\"),   mz = c(mass2mz(204.089878, \"[M+H]+\"),          mass2mz(131.094629, \"[M+H]+\"),          mass2mz(204.089878, \"[M+Na]+\") + 1e-6),   rt = c(150, 140, 150.1) )  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0)  res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1          NA             NA               NA #>     target_rt      adduct     score ppm_error  score_rt #>     <numeric> <character> <numeric> <numeric> <numeric> #> 1         150      [M+H]+         0         0         0 #> 2         140      [M+H]+         0         0         0 #> 2.1       140      [M+H]+         0         0         0 #> 3          NA          NA        NA        NA        NA  ## FT003 could not be matched to any compound, FT002 was matched to two ## different compounds (but with the same mass).  ## We repeat the matching allowing a positive tolerance for the matches ## between rt values  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0.1)  res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>     target_rt      adduct     score  ppm_error  score_rt #>     <numeric> <character> <numeric>  <numeric> <numeric> #> 1         150      [M+H]+     0e+00 0.00000000       0.0 #> 2         140      [M+H]+     0e+00 0.00000000       0.0 #> 2.1       140      [M+H]+     0e+00 0.00000000       0.0 #> 3         150     [M+Na]+     1e-06 0.00440375       0.1  ## Also FT003 was matched in this case  ## It is also possible to match directly m/z values mz1 <- c(12, 343, 23, 231) mz2 <- mz1 + rnorm(4, sd = 0.001)  res <- matchValues(mz1, mz2, MzParam(tolerance = 0.001))  matchedData(res) #> DataFrame with 4 rows and 4 columns #>    query   target        score ppm_error #>   <AsIs>   <AsIs>    <numeric> <numeric> #> 1     12  12.0006 -0.000618121 51.507450 #> 2    343 342.9996  0.000418854  1.221151 #> 3     23  23.0006 -0.000598265 26.010866 #> 4    231 230.9999  0.000124972  0.541004  ## Matching with a SummarizedExperiment or a QFeatures work analogously, ## only that the matching is performed on the object's `rowData`.  ## Below we create a simple SummarizedExperiment with some random assay data. ## Note that results from a data preprocessing with the `xcms` package could ## be extracted as a `SummarizedExperiment` with the `quantify` method from ## the `xcms` package. library(SummarizedExperiment) se <- SummarizedExperiment(     assays = matrix(rnorm(12), nrow = 3, ncol = 4),     rowData = fts)  ## We can now perform the matching of this SummarizedExperiment against the ## target_df as before. res <- matchValues(se, target_df,     param = Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),         tolerance = 0, ppm = 20)) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Getting the available columns colnames(res) #>  [1] \"feature_id\"       \"mz\"               \"rt\"               \"target_name\"      #>  [5] \"target_formula\"   \"target_exactmass\" \"target_rt\"        \"adduct\"           #>  [9] \"score\"            \"ppm_error\"         ## The query columns represent the columns of the object's `rowData` rowData(se) #> DataFrame with 3 rows and 3 columns #>    feature_id        mz        rt #>   <character> <numeric> <numeric> #> 1       FT001   205.097     150.0 #> 2       FT002   132.102     140.0 #> 3       FT003   227.079     150.1  ## matchedData also returns the query object's rowData along with the ## matching entries in the target object. matchedData(res) #> DataFrame with 4 rows and 10 columns #>    feature_id        mz        rt target_name target_formula target_exactmass #>   <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1       FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2       FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 3       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 4       FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>   target_rt      adduct     score  ppm_error #>   <numeric> <character> <numeric>  <numeric> #> 1       150      [M+H]+     0e+00 0.00000000 #> 2       140      [M+H]+     0e+00 0.00000000 #> 3       140      [M+H]+     0e+00 0.00000000 #> 4       150     [M+Na]+     1e-06 0.00440375  ## While `query` will return the full SummarizedExperiment. query(res) #> class: SummarizedExperiment  #> dim: 3 4  #> metadata(0): #> assays(1): '' #> rownames: NULL #> rowData names(3): feature_id mz rt #> colnames: NULL #> colData names(0):  ## To illustrate use with a QFeatures object we first create a simple ## QFeatures object with two assays, `\"ions\"` representing the full feature ## data.frame and `\"compounds\"` a subset of it. library(QFeatures) #> Loading required package: MultiAssayExperiment #>  #> Attaching package: ‘QFeatures’ #> The following object is masked from ‘package:MultiAssayExperiment’: #>  #>     longFormat #> The following object is masked from ‘package:base’: #>  #>     sweep qf <- QFeatures(list(ions = se, compounds = se[2,])) #> Warning: colData rownames and ExperimentList colnames are empty #> Warning: An empty 'sampleMap' may cause unexpected behavior  ## We can perform the same matching as before, but need to specify which of ## the assays in the QFeatures should be used for the matching. Below we ## perform the matching using the \"ions\" assay. res <- matchValues(qf, target_df, queryAssay = \"ions\",     param = Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),         tolerance = 0, ppm = 20)) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## colnames returns now the colnames of the `rowData` of the `\"ions\"` assay. colnames(res) #>  [1] \"feature_id\"       \"mz\"               \"rt\"               \"target_name\"      #>  [5] \"target_formula\"   \"target_exactmass\" \"target_rt\"        \"adduct\"           #>  [9] \"score\"            \"ppm_error\"         matchedData(res) #> DataFrame with 4 rows and 10 columns #>    feature_id        mz        rt target_name target_formula target_exactmass #>   <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1       FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2       FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 3       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 4       FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>   target_rt      adduct     score  ppm_error #>   <numeric> <character> <numeric>  <numeric> #> 1       150      [M+H]+     0e+00 0.00000000 #> 2       140      [M+H]+     0e+00 0.00000000 #> 3       140      [M+H]+     0e+00 0.00000000 #> 4       150     [M+Na]+     1e-06 0.00440375"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Validating MatchedSpectra — validateMatchedSpectra","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"validateMatchedSpectra() function opens simple shiny application allows browse results stored MatchedSpectra object validate presented matches. query spectrum table matched target spectra shown (available) interactive mirror plot generated. Valid matches can selected using check box displayed mirror plot. Upon pushing \"Save & Close\" button app closed filtered MatchedSpectra returned, containing validated matches.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"","code":"validateMatchedSpectra(object)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"object non-empty instance class MatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"MatchedSpectra validated results.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"Carolin Huber, Michael Witting, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"","code":"library(Spectra) ## Load test data fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L) pest_ms2 <- pest_ms2[c(808, 809, 945:955)] load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\"))  ## Normalize intensities and match spectra csp <- CompareSpectraParam(requirePrecursor = TRUE,                            THRESHFUN = function(x) x >= 0.7) norm_int <- function(x) {     x[, \"intensity\"] <- x[, \"intensity\"] / max(x[, \"intensity\"]) * 100     x } ms <- matchSpectra(addProcessing(pest_ms2, norm_int),                    addProcessing(minimb, norm_int), csp)  ## validate matches using the shiny app. Note: the call is only executed ## in interactive mode. if (interactive()) {     validateMatchedSpectra(ms) }"},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"MetaboAnnotation 1.1","text":"Extend filterMatches framework (issue #81). SelectMatchesParam TopRankedMatchesParam added perform respectively manual filtering keeping best ranked matches query element.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.15","title":"MetaboAnnotation 0.99","text":"Highlight query target spectra different colors validateMatchedSpectra. query /target type SummarizedExperiment supported Matched objects. MatchedSummarizedExperiment class removed. query /target type QFeatures supported Matched objects. Support SummarizedExperiment QFeatures query target parameters matchValues.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.14","title":"MetaboAnnotation 0.99","text":"Improve plotly-based mirror plots validateMatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.13","title":"MetaboAnnotation 0.99","text":"Fix issue matchedData working result objects matchValues, Mz2MassParam matchValues, Mz2MassRtParam (issue #69).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.12","title":"MetaboAnnotation 0.99","text":"Update plotly-based mirror plots validateMatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.11","title":"MetaboAnnotation 0.99","text":"Change matchMz matchValues (issue #65).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.10","title":"MetaboAnnotation 0.99","text":"Add validateMatchedSpectra manual inspection validation MatchedSpectra object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.9","title":"MetaboAnnotation 0.99","text":"Add setBackend MatchedSpectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.8","title":"MetaboAnnotation 0.99","text":"Add matchMz, Mz2MassParam matchMz, Mz2MassRtParam. (issue #56).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.7","title":"MetaboAnnotation 0.99","text":"Add formula matching functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.5","title":"MetaboAnnotation 0.99","text":"Add parameter ... plotSpectraMirror. Definitions “score”, “score_rt” changed difference (sign) query target m/z retention time respectively. \"ppm_error\" becomes error without sign.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.4","title":"MetaboAnnotation 0.99","text":"Add matches m/z error (variable \"ppm_error\") Matched object returned matchMz.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-11","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.3","title":"MetaboAnnotation 0.99","text":"Address Herve’s comments.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.11","title":"MetaboAnnotation 0.2","text":"Fix calculation correct number rows/columns plot plotSpectraMirror.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.10","title":"MetaboAnnotation 0.2","text":"Add parameter toleranceRt CompareSpectraParam enable retention time-based pre-filtering (issue #35).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.9","title":"MetaboAnnotation 0.2","text":"Add support manually defined adducts Mass2MzParam (issue #41).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.8","title":"MetaboAnnotation 0.2","text":"Add parameter THRESHFUN_REVERSE MatchForwardReverseParam allow filtering results forward reverse score (issue #37).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.7","title":"MetaboAnnotation 0.2","text":"Performance improvement matchSpectra precursor m/z filter used (issue #38). Report number matching peaks matchSpectra,MatchForwardReverseParam (issue #36).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.6","title":"MetaboAnnotation 0.2","text":"Fix bug matchSpectra wrongly calculating acceptable m/z difference tolerance > 0 (issue #34). Fix proposed Hugo Varet (@hvaret).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.5","title":"MetaboAnnotation 0.2","text":"Improve performance matchMz. Rename queryColumn targetColumn queryColname targetColname.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.4","title":"MetaboAnnotation 0.2","text":"Support data.frame, DataFrame matrix matchMz. Add addMatches filterMatches functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.3","title":"MetaboAnnotation 0.2","text":"Fixes MatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.2","title":"MetaboAnnotation 0.2","text":"Add MatchedSummarizedExperiment.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.1","title":"MetaboAnnotation 0.2","text":"Rename TargetMass2MzParam Mass2MzParam.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-11","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.0","title":"MetaboAnnotation 0.2","text":"Add support matching m/z m/z m/z addition retention times matchMz.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-0","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.4","title":"MetaboAnnotation 0.0","text":"Fix vignette, documentations unit tests.","code":""}]
