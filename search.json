[{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation package defines high-level user functionality support facilitate annotation MS-based metabolomics data (Rainer et al. 2022).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Annotation of MS-based Metabolomics Data","text":"package can installed BiocManager package. install BiocManager use install.packages(\"BiocManager\") , , BiocManager::install(\"MetaboAnnotation\") install package.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"example-use-cases","dir":"Articles","previous_headings":"","what":"Example use cases","title":"Annotation of MS-based Metabolomics Data","text":"following sections illustrate example use cases functionality provided MetaboAnnotation package.","code":"library(MetaboAnnotation)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z values","title":"Annotation of MS-based Metabolomics Data","text":"section simple matching feature m/z values theoretical m/z values performed. lowest level confidence metabolite anno- tation. However, gives ideas potential metabolites can analyzed downstream experiments analyses. following example loads feature table lipidomics experiments matches measured m/z values reference masses LipidMaps. use data.frame reference database, CompDb compound database instance also supported. reference (target) compounds mass available. need convert mass m/z values order match m/z values features (.e. query m/z values) . need define likely ions/adducts generated compounds based ionization used experiment. assume abundant adducts compounds \"[M+H]+\" \"[M+Na]+. next perform matching matchMz function providing query target data well parameter object (case Mass2MzParam) settings matching. Mass2MzParam, mass target compounds get first converted m/z values, based defined adducts, matched query m/z values (.e. m/z values features). get full list supported adducts MetaboCoreUtils::adductNames(polarity = \"positive\") MetaboCoreUtils::adductNames(polarity = \"negative\") can used). Note also, keep runtime vignette short, match first 100 features. tested 100 features 55 matched least one target compound (matches single compound). result object (type Matched) contains full query data frame target data frames well matching information. can access original query data query original target data target function: Functions whichQuery whichTarget can used identify rows query target data matched: can extract full matching table matchedData. returns DataFrame rows query corresponding matches target along matching adduct (column \"adduct\") difference m/z (column \"score\"). Note row query matches multiple elements target, row duplicated DataFrame returned data. rows can matched NA values reported. See also help page ?Matched details information. addition matching query m/z target exact masses described also possible match directly query m/z target m/z values using MzParam instead Mass2MzParam.","code":"ms1_features <- read.table(system.file(\"extdata\", \"MS1_example.txt\",                                        package = \"MetaboAnnotation\"),                            header = TRUE, sep = \"\\t\") head(ms1_features) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 target_df <- read.table(system.file(\"extdata\", \"LipidMaps_CompDB.txt\",                                     package = \"MetaboAnnotation\"),                         header = TRUE, sep = \"\\t\") head(target_df) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even parm <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                            tolerance = 0.005, ppm = 0)  matched_features <- matchMz(ms1_features[1:100, ], target_df, parm) matched_features ## Object of class Matched  ## Total number of matches: 55  ## Number of query objects: 100 (55 matched) ## Number of target objects: 57599 (1 matched) head(query(matched_features)) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 head(target(matched_features)) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even whichQuery(matched_features) ##  [1]  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64 ## [20]  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83 ## [39]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 whichTarget(matched_features) ## [1] 3149 matchedData(matched_features) ## DataFrame with 100 rows and 11 columns ##       feature_id        mz     rtime target_headgroup target_name ##      <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_0001   102.128   1.56015               NA          NA ## 2   Cluster_0002   102.128   2.15359               NA          NA ## 3   Cluster_0003   102.128   2.92557               NA          NA ## 4   Cluster_0004   102.128   3.41962               NA          NA ## 5   Cluster_0005   102.127   5.80104               NA          NA ## ...          ...       ...       ...              ...         ... ## 96  Cluster_0096   201.113   11.2722               FA  FA 10:2;O2 ## 97  Cluster_0097   201.113   11.4081               FA  FA 10:2;O2 ## 98  Cluster_0098   201.113   11.4760               FA  FA 10:2;O2 ## 99  Cluster_0099   201.114   11.5652               FA  FA 10:2;O2 ## 100 Cluster_0100   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type      adduct     score ##            <numeric>    <character>       <character> <character> <numeric> ## 1                 NA             NA                NA          NA        NA ## 2                 NA             NA                NA          NA        NA ## 3                 NA             NA                NA          NA        NA ## 4                 NA             NA                NA          NA        NA ## 5                 NA             NA                NA          NA        NA ## ...              ...            ...               ...         ...       ... ## 96           200.105       C10H16O4              even      [M+H]+ 0.0007312 ## 97           200.105       C10H16O4              even      [M+H]+ 0.0005444 ## 98           200.105       C10H16O4              even      [M+H]+ 0.0005328 ## 99           200.105       C10H16O4              even      [M+H]+ 0.0014619 ## 100          200.105       C10H16O4              even      [M+H]+ 0.0020342 ##     ppm_error ##     <numeric> ## 1          NA ## 2          NA ## 3          NA ## 4          NA ## 5          NA ## ...       ... ## 96    3.63578 ## 97    2.70695 ## 98    2.64927 ## 99    7.26908 ## 100  10.11476"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-and-retention-time-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z and retention time values","title":"Annotation of MS-based Metabolomics Data","text":"expected retention time values available target compounds, annotation higher confidence performed matchMz Mass2MzRtParam parameter object. illustrate randomly assign retention times query features target compounds adding also 2 seconds difference. real use case target data.frame contain masses (m/z values) standards along retention times ions standards measured LC-MS setup query data derives. subset data table MS1 features first 100 rows (keep runtime vignette short). table contains thus retention times features column named \"rtime\". Next randomly assign retention times features compounds target data adding deviation 2 seconds. described , real use case retention times supposed determined measuring compounds LC-MS setup. now retention times available query target data can thus perform matching based m/z retention times. use Mass2MzRtParam allows us specify (Mass2MzParam) expected adducts, maximal acceptable m/z relative absolute deviation well maximal acceptable (absolute) difference retention times. use settings previous section allow difference 10 seconds retention times. retention times provided columns named \"rtime\" different default (\"rt\"). thus specify name column containing retention times parameter rtColname. Less features matched based m/z retention times.","code":"ms1_subset <- ms1_features[1:100, ] head(ms1_subset) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 set.seed(123) target_df$rtime <- sample(ms1_subset$rtime,                           nrow(target_df), replace = TRUE) + 2 parm <- Mass2MzRtParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                        tolerance = 0.005, ppm = 0,                        toleranceRt = 10) matched_features <- matchMz(ms1_subset, target_df, param = parm,                             rtColname = \"rtime\") matched_features ## Object of class Matched  ## Total number of matches: 31  ## Number of query objects: 100 (31 matched) ## Number of target objects: 57599 (1 matched) matchedData(matched_features)[whichQuery(matched_features), ] ## DataFrame with 31 rows and 13 columns ##       feature_id        mz     rtime target_headgroup target_name ##      <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_0070   201.113   5.87206               FA  FA 10:2;O2 ## 2   Cluster_0071   201.113   5.93346               FA  FA 10:2;O2 ## 3   Cluster_0072   201.113   6.03653               FA  FA 10:2;O2 ## 4   Cluster_0073   201.114   6.16709               FA  FA 10:2;O2 ## 5   Cluster_0074   201.113   6.31781               FA  FA 10:2;O2 ## ...          ...       ...       ...              ...         ... ## 27  Cluster_0096   201.113   11.2722               FA  FA 10:2;O2 ## 28  Cluster_0097   201.113   11.4081               FA  FA 10:2;O2 ## 29  Cluster_0098   201.113   11.4760               FA  FA 10:2;O2 ## 30  Cluster_0099   201.114   11.5652               FA  FA 10:2;O2 ## 31  Cluster_0100   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type target_rtime      adduct ##            <numeric>    <character>       <character>    <numeric> <character> ## 1            200.105       C10H16O4              even      15.8624      [M+H]+ ## 2            200.105       C10H16O4              even      15.8624      [M+H]+ ## 3            200.105       C10H16O4              even      15.8624      [M+H]+ ## 4            200.105       C10H16O4              even      15.8624      [M+H]+ ## 5            200.105       C10H16O4              even      15.8624      [M+H]+ ## ...              ...            ...               ...          ...         ... ## 27           200.105       C10H16O4              even      15.8624      [M+H]+ ## 28           200.105       C10H16O4              even      15.8624      [M+H]+ ## 29           200.105       C10H16O4              even      15.8624      [M+H]+ ## 30           200.105       C10H16O4              even      15.8624      [M+H]+ ## 31           200.105       C10H16O4              even      15.8624      [M+H]+ ##         score ppm_error  score_rt ##     <numeric> <numeric> <numeric> ## 1   0.0004538   2.25645  -9.99030 ## 2   0.0004407   2.19131  -9.92890 ## 3   0.0005655   2.81186  -9.82583 ## 4   0.0015560   7.73698  -9.69527 ## 5   0.0006845   3.40357  -9.54455 ## ...       ...       ...       ... ## 27  0.0007312   3.63578  -4.59014 ## 28  0.0005444   2.70695  -4.45431 ## 29  0.0005328   2.64927  -4.38634 ## 30  0.0014619   7.26908  -4.29719 ## 31  0.0020342  10.11476  -4.08719"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-msms-spectra","dir":"Articles","previous_headings":"Example use cases","what":"Matching of MS/MS spectra","title":"Annotation of MS-based Metabolomics Data","text":"section match experimental MS/MS spectra reference spectra. can also performed functions Spectra package (see SpectraTutorials, functions concepts used suitable end user simplify handling spectra matching results. load spectra file reversed-phase (DDA) LC-MS/MS run Agilent Pesticide mix. filterMsLevel subset data set MS2 spectra. reduce processing time example subset Spectra small set selected MS2 spectra. addition assign feature identifiers spectrum (, example arbitrary IDs, real data analysis identifiers indicate LC-MS feature spectra belong). Spectra now represent MS2 spectra associated LC-MS features untargeted LC-MS/MS experiment like annotate matching spectral reference library. thus load Spectra object represents MS2 data small subset MassBank release 2021.03. small Spectra object provided within package possible use Spectra object instead (see SpectraTutorials different ways options provide access spectral libraries/databases via Spectra). can now use matchSpectra function match experimental query spectra target (reference) spectra. Settings matching can defined dedicated param object. use CompareSpectraParam uses compareSpectra function Spectra package calculate similarities query spectrum target spectra. CompareSpectraParam allows set individual settings compareSpectra call parameters MAPFUN, ppm, tolerance FUN (see help compareSpectra Spectra package details). addition, can pre-filter target spectra individual query spectrum speed-calculations. setting requirePrecursor = TRUE compare query spectrum target spectra matching precursor m/z (accepting deviation defined parameters ppm tolerance). default, matchSpectra CompareSpectraParam considers spectra similarity score higher 0.7 matching thus reported. results reported MatchedSpectra object represents matching results query spectra. type object contains query spectra, target spectra, matching information parameter object settings matching. object can subsetted e.g. matching results specific query spectrum: case, first query spectrum, match found among target spectra. subset MatchedSpectra results second query spectrum: second query spectrum matched 4 target spectra. matching query target spectra can n:m, .e. query spectrum can match multiple target spectra target spectrum can matched none, one multiple query spectra. Data (spectra variables either query /target spectra) can extracted result object spectraData function $ (similar Spectra object). spectraVariables function can used list available spectra variables result object: lists spectra variables query target spectra, prefix \"target_\" used spectra variable names target spectra. Spectra variable \"score\" contains similarity score. thus use $target_compound_name extract compound name matching target spectra second query spectrum: information can also extracted full MatchedSpectra. use $spectrum_id extract query spectra identifiers added full result object. n:m mapping query target spectra, number values returned $ (spectraData) can larger total number query spectra. Also example , spectra IDs present result returned $spectrum_id. respective spectra matched one target spectrum (based settings) hence IDs reported multiple times. spectraData $ MatchedSpectra use left join strategy report/return values: value (row) reported query spectrum (even match target spectrum) eventually duplicated values (rows) query spectrum matches one target spectrum (value query spectrum repeated many times matches target spectra). illustrate use spectraData function extract specific data result object, .e. spectrum feature IDs query spectra defined , MS2 spectra similarity score, target spectra’s ID compound name. Using plotSpectraMirror function can visualize matching results one query spectrum. call function show matches second spectrum.  unexpectedly, peak intensities query target spectra different scales. problem similarity calculation (normalized dot-product used default independent absolute peak values) ideal visualization. Thus, apply normalization function query target spectra plot spectra afterwards (see help addProcessing Spectra package details spectra data manipulations). function replace absolute spectra intensities intensities relative maximum intensity spectrum.  query spectrum seems nicely match identified target spectra. extract compound name target spectra second query spectrum. alternative CompareSpectraParam also use MatchForwardReverseParam matchSpectra. settings performs spectra similarity search CompareSpectraParam, reports addition (similar MS-DIAL) (forward) similarity score also reverse spectra similarity score well presence ratio matching spectra. default forward score calculated considering peaks query target spectrum (peak mapping performed using outer join strategy), reverse score calculated peaks present target spectrum matching peaks query spectrum (peak mapping performed using right join strategy). presence ratio ratio number mapped peaks query target spectrum total number peaks target spectrum. values available spectra variables \"reverse_score\" \"presence_ratio\" result object). perform spectra matching , using MatchForwardReverseParam. extract query target spectra IDs, compound name scores. examples matched query spectra target spectra precursor m/z ~ equal reported matches similarity higher 0.7. CompareSpectraParam, parameter THRESHFUN however also allow types analyses. example also report best matching target spectrum query spectrum, independently whether similarity score higher certain threshold. perform analysis defining THRESHFUN selects always best match. Note whole example work Spectra object MS2 spectra. objects also extracted xcms-based LC-MS/MS data analysis chromPeaksSpectra featureSpectra functions xcms package. Also,","code":"library(Spectra) library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L) ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)] ## assign arbitrary *feature IDs* to each spectrum. pest_ms2$feature_id <- c(\"FT001\", \"FT001\", \"FT002\", \"FT003\", \"FT003\", \"FT003\",                          \"FT004\", \"FT004\", \"FT004\", \"FT005\", \"FT005\", \"FT006\",                          \"FT006\") ## assign also *spectra IDs* to each pest_ms2$spectrum_id <- paste0(\"sp_\", seq_along(pest_ms2)) pest_ms2 ## MSn data (Spectra) with 13 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2   361.651      2853 ## 2           2   361.741      2854 ## 3           2   377.609      3030 ## 4           2   377.699      3031 ## 5           2   378.120      3033 ## ...       ...       ...       ... ## 9           2   378.959      3039 ## 10          2   379.379      3041 ## 11          2   380.059      3045 ## 12          2   380.609      3048 ## 13          2   381.029      3050 ##  ... 35 more variables/columns. ##  ## file(s): ## PestMix1_DDA.mzML ## Processing: ##  Filter: select MS level(s) 2 [Fri Feb 25 11:30:10 2022] load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\")) minimb ## MSn data (Spectra) with 100 spectra in a MsBackendDataFrame backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2        NA        NA ## 2           2        NA        NA ## 3           2        NA        NA ## 4           2        NA        NA ## 5           2        NA        NA ## ...       ...       ...       ... ## 96         NA        NA        NA ## 97          2        NA        NA ## 98          2        NA        NA ## 99          2        NA        NA ## 100         2        NA        NA ##  ... 42 more variables/columns. ## Processing: ##  Filter: select spectra with polarity 1 [Wed Mar 31 10:06:28 2021] ##  Switch backend from MsBackendMassbankSql to MsBackendDataFrame [Wed Mar 31 10:07:59 2021] mtches <- matchSpectra(pest_ms2, minimb,                        param = CompareSpectraParam(requirePrecursor = TRUE,                                                    ppm = 10)) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) mtches[1] ## Object of class MatchedSpectra  ## Total number of matches: 0  ## Number of query objects: 1 (0 matched) ## Number of target objects: 100 (0 matched) mtches[2] ## Object of class MatchedSpectra  ## Total number of matches: 4  ## Number of query objects: 1 (1 matched) ## Number of target objects: 100 (4 matched) spectraVariables(mtches) ##  [1] \"msLevel\"                        \"rtime\"                          ##  [3] \"acquisitionNum\"                 \"scanIndex\"                      ##  [5] \"dataStorage\"                    \"dataOrigin\"                     ##  [7] \"centroided\"                     \"smoothed\"                       ##  [9] \"polarity\"                       \"precScanNum\"                    ## [11] \"precursorMz\"                    \"precursorIntensity\"             ## [13] \"precursorCharge\"                \"collisionEnergy\"                ## [15] \"isolationWindowLowerMz\"         \"isolationWindowTargetMz\"        ## [17] \"isolationWindowUpperMz\"         \"peaksCount\"                     ## [19] \"totIonCurrent\"                  \"basePeakMZ\"                     ## [21] \"basePeakIntensity\"              \"ionisationEnergy\"               ## [23] \"lowMZ\"                          \"highMZ\"                         ## [25] \"mergedScan\"                     \"mergedResultScanNum\"            ## [27] \"mergedResultStartScanNum\"       \"mergedResultEndScanNum\"         ## [29] \"injectionTime\"                  \"filterString\"                   ## [31] \"spectrumId\"                     \"ionMobilityDriftTime\"           ## [33] \"scanWindowLowerLimit\"           \"scanWindowUpperLimit\"           ## [35] \"feature_id\"                     \"spectrum_id\"                    ## [37] \"target_msLevel\"                 \"target_rtime\"                   ## [39] \"target_acquisitionNum\"          \"target_scanIndex\"               ## [41] \"target_dataStorage\"             \"target_dataOrigin\"              ## [43] \"target_centroided\"              \"target_smoothed\"                ## [45] \"target_polarity\"                \"target_precScanNum\"             ## [47] \"target_precursorMz\"             \"target_precursorIntensity\"      ## [49] \"target_precursorCharge\"         \"target_collisionEnergy\"         ## [51] \"target_isolationWindowLowerMz\"  \"target_isolationWindowTargetMz\" ## [53] \"target_isolationWindowUpperMz\"  \"target_spectrum_id\"             ## [55] \"target_spectrum_name\"           \"target_date\"                    ## [57] \"target_authors\"                 \"target_license\"                 ## [59] \"target_copyright\"               \"target_publication\"             ## [61] \"target_splash\"                  \"target_compound_id\"             ## [63] \"target_adduct\"                  \"target_ionization\"              ## [65] \"target_ionization_voltage\"      \"target_fragmentation_mode\"      ## [67] \"target_collision_energy_text\"   \"target_instrument\"              ## [69] \"target_instrument_type\"         \"target_formula\"                 ## [71] \"target_exactmass\"               \"target_smiles\"                  ## [73] \"target_inchi\"                   \"target_inchikey\"                ## [75] \"target_cas\"                     \"target_pubchem\"                 ## [77] \"target_synonym\"                 \"target_precursor_mz_text\"       ## [79] \"target_compound_name\"           \"score\" mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mtches$spectrum_id ##  [1] \"sp_1\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_3\"  \"sp_4\"  \"sp_4\"  \"sp_5\"  ## [10] \"sp_6\"  \"sp_6\"  \"sp_6\"  \"sp_7\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  ## [19] \"sp_9\"  \"sp_9\"  \"sp_10\" \"sp_11\" \"sp_12\" \"sp_13\" mtches_df <- spectraData(mtches, columns = c(\"spectrum_id\", \"feature_id\",                                              \"score\", \"target_spectrum_id\",                                              \"target_compound_name\")) as.data.frame(mtches_df) ##    spectrum_id feature_id     score target_spectrum_id    target_compound_name ## 1         sp_1      FT001        NA               <NA>                    <NA> ## 2         sp_2      FT001 0.7869556           LU056604             Azaconazole ## 3         sp_2      FT001 0.8855473           LU056603             Azaconazole ## 4         sp_2      FT001 0.7234894           LU056602             Azaconazole ## 5         sp_2      FT001 0.7219942           LU056605             Azaconazole ## 6         sp_3      FT002        NA               <NA>                    <NA> ## 7         sp_4      FT003 0.7769746           KW108103 triphenylphosphineoxide ## 8         sp_4      FT003 0.7577286           KW108102 triphenylphosphineoxide ## 9         sp_5      FT003        NA               <NA>                    <NA> ## 10        sp_6      FT003 0.7433718           SM839501            Dimethachlor ## 11        sp_6      FT003 0.7019807           EA070705            Dimethachlor ## 12        sp_6      FT003 0.7081274           EA070711            Dimethachlor ## 13        sp_7      FT004        NA               <NA>                    <NA> ## 14        sp_8      FT004 0.7320465           SM839501            Dimethachlor ## 15        sp_8      FT004 0.8106258           EA070705            Dimethachlor ## 16        sp_8      FT004 0.7290458           EA070710            Dimethachlor ## 17        sp_8      FT004 0.8168876           EA070711            Dimethachlor ## 18        sp_8      FT004 0.7247800           EA070704            Dimethachlor ## 19        sp_9      FT004 0.7412586           KW108103 triphenylphosphineoxide ## 20        sp_9      FT004 0.7198787           KW108102 triphenylphosphineoxide ## 21       sp_10      FT005        NA               <NA>                    <NA> ## 22       sp_11      FT005        NA               <NA>                    <NA> ## 23       sp_12      FT006        NA               <NA>                    <NA> ## 24       sp_13      FT006        NA               <NA>                    <NA> plotSpectraMirror(mtches[2]) norm_int <- function(x) {     x[, \"intensity\"] <- x[, \"intensity\"] / max(x[, \"intensity\"], na.rm = TRUE)     x } mtches <- addProcessing(mtches, norm_int) plotSpectraMirror(mtches[2]) mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mp <- MatchForwardReverseParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, param = mp) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) as.data.frame(     spectraData(mtches, c(\"spectrum_id\", \"target_spectrum_id\",                           \"target_compound_name\", \"score\", \"reverse_score\",                           \"presence_ratio\"))) ##    spectrum_id target_spectrum_id    target_compound_name     score ## 1         sp_1               <NA>                    <NA>        NA ## 2         sp_2           LU056604             Azaconazole 0.7869556 ## 3         sp_2           LU056603             Azaconazole 0.8855473 ## 4         sp_2           LU056602             Azaconazole 0.7234894 ## 5         sp_2           LU056605             Azaconazole 0.7219942 ## 6         sp_3               <NA>                    <NA>        NA ## 7         sp_4           KW108103 triphenylphosphineoxide 0.7769746 ## 8         sp_4           KW108102 triphenylphosphineoxide 0.7577286 ## 9         sp_5               <NA>                    <NA>        NA ## 10        sp_6           SM839501            Dimethachlor 0.7433718 ## 11        sp_6           EA070705            Dimethachlor 0.7019807 ## 12        sp_6           EA070711            Dimethachlor 0.7081274 ## 13        sp_7               <NA>                    <NA>        NA ## 14        sp_8           SM839501            Dimethachlor 0.7320465 ## 15        sp_8           EA070705            Dimethachlor 0.8106258 ## 16        sp_8           EA070710            Dimethachlor 0.7290458 ## 17        sp_8           EA070711            Dimethachlor 0.8168876 ## 18        sp_8           EA070704            Dimethachlor 0.7247800 ## 19        sp_9           KW108103 triphenylphosphineoxide 0.7412586 ## 20        sp_9           KW108102 triphenylphosphineoxide 0.7198787 ## 21       sp_10               <NA>                    <NA>        NA ## 22       sp_11               <NA>                    <NA>        NA ## 23       sp_12               <NA>                    <NA>        NA ## 24       sp_13               <NA>                    <NA>        NA ##    reverse_score presence_ratio ## 1             NA             NA ## 2      0.8764394      0.5833333 ## 3      0.9239592      0.6250000 ## 4      0.7573541      0.6250000 ## 5      0.9519647      0.4285714 ## 6             NA             NA ## 7      0.9025051      0.7500000 ## 8      0.9164348      0.5000000 ## 9             NA             NA ## 10     0.8915201      0.5000000 ## 11     0.8687003      0.3333333 ## 12     0.8687472      0.3703704 ## 13            NA             NA ## 14     0.8444402      0.5000000 ## 15     0.9267965      0.5000000 ## 16     0.8765496      0.7500000 ## 17     0.9236674      0.4814815 ## 18     0.8714208      0.8571429 ## 19     0.8743130      0.7500000 ## 20     0.8937751      0.5000000 ## 21            NA             NA ## 22            NA             NA ## 23            NA             NA ## 24            NA             NA select_top_match <- function(x) {     which.max(x) } csp <- CompareSpectraParam(ppm = 10, requirePrecursor = FALSE,                            THRESHFUN = select_top_match) mtches <- matchSpectra(pest_ms2, minimb, param = csp) res <- spectraData(mtches, columns = c(\"spectrum_id\", \"target_spectrum_id\",                                        \"target_compound_name\", \"score\")) as.data.frame(res) ##    spectrum_id target_spectrum_id                   target_compound_name ## 1         sp_1           SM839603                             Flufenacet ## 2         sp_2           LU056603                            Azaconazole ## 3         sp_3           SM839501                           Dimethachlor ## 4         sp_4           KW108103                triphenylphosphineoxide ## 5         sp_5           LU100202        2,2'-(Tetradecylimino)diethanol ## 6         sp_6           SM839501                           Dimethachlor ## 7         sp_7           RP005503              Glycoursodeoxycholic acid ## 8         sp_8           EA070711                           Dimethachlor ## 9         sp_9           KW108103                triphenylphosphineoxide ## 10       sp_10           JP006901                  1-PHENYLETHYL ACETATE ## 11       sp_11           EA070711                           Dimethachlor ## 12       sp_12           EA070705                           Dimethachlor ## 13       sp_13           LU101704 2-Ethylhexyl 4-(dimethylamino)benzoate ##           score ## 1  0.000000e+00 ## 2  8.855473e-01 ## 3  6.313687e-01 ## 4  7.769746e-01 ## 5  1.772117e-05 ## 6  7.433718e-01 ## 7  1.906998e-03 ## 8  8.168876e-01 ## 9  7.412586e-01 ## 10 4.085289e-04 ## 11 4.323403e-01 ## 12 3.469648e-03 ## 13 7.612480e-06"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Annotation of MS-based Metabolomics Data","text":"","code":"## R Under development (unstable) (2022-02-17 r81757) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ##  ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ## [1] msdata_0.35.2           Spectra_1.5.11          ProtGenerics_1.27.2     ## [4] BiocParallel_1.29.15    S4Vectors_0.33.10       BiocGenerics_0.41.2     ## [7] MetaboAnnotation_0.99.7 BiocStyle_2.23.1        ##  ## loaded via a namespace (and not attached): ##  [1] SummarizedExperiment_1.25.3 xfun_0.29                   ##  [3] bslib_0.3.1                 purrr_0.3.4                 ##  [5] lattice_0.20-45             htmltools_0.5.2             ##  [7] yaml_2.3.5                  rlang_1.0.1                 ##  [9] pkgdown_2.0.2.9000          jquerylib_0.1.4             ## [11] mzR_2.29.3                  MetaboCoreUtils_1.3.7       ## [13] matrixStats_0.61.0-9001     GenomeInfoDbData_1.2.7      ## [15] stringr_1.4.0               MatrixGenerics_1.7.0        ## [17] zlibbioc_1.41.0             ragg_1.2.2                  ## [19] codetools_0.2-18            memoise_2.0.1               ## [21] evaluate_0.15               Biobase_2.55.0              ## [23] knitr_1.37                  IRanges_2.29.1              ## [25] fastmap_1.1.0               GenomeInfoDb_1.31.4         ## [27] parallel_4.2.0              highr_0.9                   ## [29] Rcpp_1.0.8                  BiocManager_1.30.16         ## [31] cachem_1.0.6                DelayedArray_0.21.2         ## [33] desc_1.4.0                  jsonlite_1.8.0              ## [35] XVector_0.35.0              MsCoreUtils_1.7.4           ## [37] systemfonts_1.0.4           fs_1.5.2                    ## [39] textshaping_0.3.6           digest_0.6.29               ## [41] stringi_1.7.6               bookdown_0.24               ## [43] ncdf4_1.19                  grid_4.2.0                  ## [45] GenomicRanges_1.47.6        rprojroot_2.0.2             ## [47] clue_0.3-60                 cli_3.2.0                   ## [49] tools_4.2.0                 bitops_1.0-7                ## [51] magrittr_2.0.2              sass_0.4.0                  ## [53] RCurl_1.98-1.6              cluster_2.1.2               ## [55] crayon_1.5.0                MASS_7.3-55                 ## [57] Matrix_1.4-0                rmarkdown_2.11              ## [59] R6_2.5.1                    compiler_4.2.0"},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Witting. Author. Johannes Rainer. Author, maintainer. Andrea Vicini. Author.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J, Vicini , Salzer L, Stanstrup J, Badia JM, Neumann S, Stravs MA, Verri Hernandes V, Gatto L, Gibb S Wittin M. Modular Expandable Ecosystem Metabolomics Data Annotation R Metabolites 2022, 12, 173. https://doi.org/10.3390/metabo12020173","code":"@Article{,   title = {A Modular and Expandable Ecosystem for Metabolomics Data Annotation in R},   author = {Johannes Rainer and Andrea Vicini and Liesa Salzer and Jan Stanstrup and Josep M. Badia and Steffen Neumann and Michael A. Stravs and Vinicius {Verri Hernandes} and Laurent Gatto and Sebastian Gibb and Michael Witting},   journal = {Metabolites},   year = {2022},   doi = {10.3390/metabo12020173},   url = {https://www.mdpi.com/2218-1989/12/2/173},   volume = {12},   pages = {173}, }"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"metaboannotation","dir":"","previous_headings":"","what":"Utilities for Annotation of Metabolomics Data","title":"Utilities for Annotation of Metabolomics Data","text":"High level functions assist annotation (metabolomics) data sets. include functions perform simple tentative annotations based mass matching also functions consider m/z retention times annotation LC-MS features given respective reference values available. addition, function provides high-level functions simplify matching LC-MS/MS spectra spectral libraries objects functionality represent manage matched data.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Utilities for Annotation of Metabolomics Data","text":"Contributions generally welcome, follow contribution guidelines. Also, please check coding style guidelines RforMassSpectrometry vignette.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"authors-and-contributors","dir":"","previous_headings":"","what":"Authors and Contributors","title":"Utilities for Annotation of Metabolomics Data","text":"Andrea Vicini Michael Witting Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching MS Spectra against a reference — CompareSpectraParam","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"matchSpectra query target Spectra object matches spectra query spectra target reports matches similarity passes THRESHFUN condition. parameters matching can specified one param objects listed : CompareSpectraParam: generic parameter object allowing set settings compareSpectra() call used perform similarity calculation. includes MAPFUN FUN defining peak-mapping similarity calculation functions ppm tolerance define acceptable difference m/z values compared peaks. Additional parameters compareSpectra call can passed along .... See help Spectra() information parameters. Parameters requirePrecursor (default TRUE) requirePrecursorPeak (default FALSE) allow pre-filter target spectra prior actual similarity calculation individual query spectrum. Target spectra can also pre-filtered based retention time parameter toleranceRt set value different default toleranceRt = Inf. target spectra retention time within query's retention time +/- (toleranceRt + percentRt% query's retention time) considered. Note ppm tolerance single value accepted, toleranceRt percentRt can also length equal number query spectra hence allowing define different rt boundaries query spectrum. pre-filters can considerably improve performance, noted matches found query target spectra missing values considered variable (precursor m/z retention time). target spectra without retention times (Spectra public reference database MassBank) default toleranceRt = Inf thus used. Finally, parameter THRESHFUN allows define function applied similarity scores define matches report. See details. MatchForwardReverseParam: performs spectra matching CompareSpectraParam reports, similar MS-DIAL, also reverse similarity score presence ratio. detail, matching query spectra target spectra performed considering peaks query peaks target (reference) spectrum (.e. forward matching using outer join-based peak matching strategy). matching spectra also reverse similarity calculated considering peaks present target (reference) spectrum (.e. using right join-based peak matching). reported spectra variable \"reverse_score\". addition, ratio number matched peaks total number peaks target (reference) spectra reported presence ratio (spectra variable \"presence_ratio\") total number matched peaks \"matched_peaks_count\". See examples details. Parameter THRESHFUN_REVERSE allows define additional threshold function filter matches. THRESHFUN_REVERSE defined matches spectra similarity fulfilling THRESHFUN THRESHFUN_REVERSE returned. default THRESHFUN_REVERSE = NULL matches passing THRESHFUN reported.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"","code":"CompareSpectraParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   toleranceRt = Inf,   percentRt = 0,   ... )  MatchForwardReverseParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   THRESHFUN_REVERSE = NULL,   toleranceRt = Inf,   percentRt = 0,   ... )  # S4 method for Spectra,Spectra,CompareSpectraParam matchSpectra(query, target, param, BPPARAM = BiocParallel::SerialParam())  # S4 method for Spectra,Spectra,MatchForwardReverseParam matchSpectra(query, target, param, BPPARAM = BiocParallel::SerialParam())"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"MAPFUN function used map peaks compared spectra. Defaults CompareSpectraParam joinPeaks(). See compareSpectra() details. tolerance numeric(1) absolute maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. ppm numeric(1) relative, m/z-dependent, maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. FUN function used calculate similarity spectra. Defaults CompareSpectraParam MsCoreUtils::ndotproduct(). See MsCoreUtils::ndotproduct() details. requirePrecursor logical(1) whether target spectra considered similarity calculation precursor m/z matches precursor m/z query spectrum (considering also ppm tolerance). requirePrecursor = TRUE (default) function complete much faster, find hits target (query spectra) missing precursor m/z. suggested check first availability precursor m/z target query. requirePrecursorPeak logical(1) whether target spectra considered spectra similarity calculation peak m/z matching precursor m/z query spectrum. Defaults requirePrecursorPeak = FALSE. suggested check first availability precursor m/z query, match reported query spectra missing precursor m/z. THRESHFUN function applied similarity score define target spectra considered matching. Defaults THRESHFUN = function(x) (x >= 0.7) hence selects target spectra matching query spectrum similarity higher equal 0.7. function takes numeric vector similarity scores comparison query spectrum target spectra (returned compareSpectra()) input returns logical vector (dimensions similarity scores) integer matches supported. toleranceRt numeric length 1 equal number query spectra defining maximal accepted (absolute) difference retention time query target spectra. default (toleranceRt = Inf) retention time-based filter considered. See help CompareSpectraParam information. percentRt numeric length 1 equal number query spectra defining maximal accepted relative difference retention time query target spectra expressed percentage query rt. percentRt = 10, similarities defined query spectrum target spectra retention time within query rt +/- 10% query. default (toleranceRt = Inf) retention time-based filter considered. Thus, consider percentRt parameter, toleranceRt set value different . See help CompareSpectraParam information. ... CompareSpectraParam: additional parameters passed along compareSpectra() call. THRESHFUN_REVERSE MatchForwardReverseParam: optional additional thresholding function filter results reverse score. specified format THRESHFUN expected. query matchSpectra: Spectra object query spectra. target matchSpectra: Spectra object target (reference) spectra compare query . param matchSpectra: parameter object (CompareSpectraParam) defining settings matching. BPPARAM matchSpectra: parallel processing setup (see BiocParallel package information). Parallel processing disabled default.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"matchSpectra returns MatchedSpectra() object. Constructor functions return instance class.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"Johannes Rainer, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching MS Spectra against a reference — CompareSpectraParam","text":"","code":"library(Spectra) #> Loading required package: S4Vectors #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table, #>     tapply, union, unique, unsplit, which.max, which.min #>  #> Attaching package: ‘S4Vectors’ #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: BiocParallel #> Loading required package: ProtGenerics #>  #> Attaching package: ‘ProtGenerics’ #> The following object is masked from ‘package:MetaboAnnotation’: #>  #>     addProcessing #> The following object is masked from ‘package:stats’: #>  #>     smooth #>  #> Attaching package: ‘Spectra’ #> The following object is masked from ‘package:ProtGenerics’: #>  #>     addProcessing library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L)  ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)]  ## Load a small example MassBank data set load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\"))  ## Match spectra with the default similarity score (normalized dot product) csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, csp)  mtches #> Object of class MatchedSpectra  #> Total number of matches: 16  #> Number of query objects: 13 (5 matched) #> Number of target objects: 100 (11 matched)  ## Are there any matching spectra for the first query spectrum? mtches[1] #> Object of class MatchedSpectra  #> Total number of matches: 0  #> Number of query objects: 1 (0 matched) #> Number of target objects: 100 (0 matched) ## No  ## And for the second query spectrum? mtches[2] #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 1 (1 matched) #> Number of target objects: 100 (4 matched) ## The second query spectrum matches 4 target spectra. The scores for these ## matches are: mtches[2]$score #> [1] 0.7869556 0.8855473 0.7234894 0.7219942  ## To access the score for the full data set mtches$score #>  [1]        NA 0.7869556 0.8855473 0.7234894 0.7219942        NA 0.7769746 #>  [8] 0.7577286        NA 0.7433718 0.7019807 0.7081274        NA 0.7320465 #> [15] 0.8106258 0.7290458 0.8168876 0.7247800 0.7412586 0.7198787        NA #> [22]        NA        NA        NA  ## Below we use a THRESHFUN that returns for each query spectrum the (first) ## best matching target spectrum. csp <- CompareSpectraParam(requirePrecursor = FALSE, ppm = 10,     THRESHFUN = function(x) which.max(x)) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 13  #> Number of query objects: 13 (13 matched) #> Number of target objects: 100 (10 matched)  ## Each of the query spectra is matched to one target spectrum length(mtches) #> [1] 13 matches(mtches) #>    query_idx target_idx        score #> 1          1          1 0.000000e+00 #> 2          2         73 8.855473e-01 #> 3          3          2 6.313687e-01 #> 4          4         44 7.769746e-01 #> 5          5         74 1.772117e-05 #> 6          6          2 7.433718e-01 #> 7          7          5 1.906998e-03 #> 8          8         53 8.168876e-01 #> 9          9         44 7.412586e-01 #> 10        10         86 4.085289e-04 #> 11        11         53 4.323403e-01 #> 12        12         47 3.469648e-03 #> 13        13         71 7.612480e-06  ## Match spectra considering also measured retention times. This requires ## that both query and target spectra have non-missing retention times. rtime(pest_ms2) #>  [1] 361.651 361.741 377.609 377.699 378.120 378.539 378.779 378.869 378.959 #> [10] 379.379 380.059 380.609 381.029 rtime(minimb) #>   [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA  ## Target spectra don't have retention times. Below we artificially set ## retention times to show how an additional retention time filter would ## work. rtime(minimb) <- rep(361, length(minimb))  ## Matching spectra requiring a matching precursor m/z and the difference ## of retention times between query and target spectra to be <= 2 seconds. csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10,     toleranceRt = 2) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 13 (1 matched) #> Number of target objects: 100 (4 matched) matches(mtches) #>   query_idx target_idx     score #> 1         2         70 0.7869556 #> 2         2         73 0.8855473 #> 3         2         75 0.7234894 #> 4         2         76 0.7219942  ## See the package vignette for details, descriptions and more examples."},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of generic objects matches — addMatches","title":"Representation of generic objects matches — addMatches","text":"Matches query target generic objects can represented Matched object. default, data accessors work left joins query target object, .e. values returned query object eventual duplicated entries (values) query object matches one target object. See also Creation subsetting well Extracting data sections details information MatchedSummarizedExperiment object allows represent matches SummarizedExperiment() object target object (can , like Matched object, data.frame, matrix, vector list). Matches represent links rows SummarizedExperiment target, hence, colnames matchedData access rowData() matched SummarizedExperiment.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of generic objects matches — addMatches","text":"","code":"addMatches(object, ...)  filterMatches(object, ...)  matchedData(object, ...)  Matched(   query = list(),   target = list(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score =     numeric()),   metadata = list() )  # S4 method for Matched length(x)  # S4 method for Matched show(object)  # S4 method for Matched,ANY,ANY,ANY [(x, i, j, ..., drop = FALSE)  matches(object)  target(object)  query(object)  whichTarget(object)  whichQuery(object)  # S4 method for Matched $(x, name)  # S4 method for Matched colnames(x)  # S4 method for Matched matchedData(object, columns = colnames(object), ...)  pruneTarget(object)  # S4 method for Matched filterMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE,   ... )  # S4 method for Matched addMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   score = rep(NA_real_, length(queryValue)),   isIndex = FALSE )  MatchedSummarizedExperiment(   query = SummarizedExperiment(),   target = data.frame(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score =     numeric()),   metadata = list() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of generic objects matches — addMatches","text":"object Matched object. ... additional parameters. query object query elements. target object elements query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target objects. metadata list optional additional metadata. x Matched object. integer logical defining query elements keep. j [: ignored. drop [: ignored. name $: name column (variable) extract. columns matchedData: character vector column names variables extracted. queryValue filterMatches: vector values search query (query 1-dimensional) column queryColname query (query 2-dimensional). addMatches: either index query value column queryColname query defining (together targetValue) pair query target elements match manually added. Lengths queryValue targetValue match. targetValue filterMatches: vector values search target (target 1-dimensional) column targetColname target (target 2-dimensional). addMatches: either index target value column targetColname target defining (together queryValue) pair query target elements match manually added. Lengths queryValue targetValue match. queryColname query 2-dimensional: column query elements queryValue compared. targetColname query 2-dimensional: column target elements targetValue compared. index filterMatches: indices matches keep (keep = TRUE) drop (keep = FALSE). keep filterMatches: logical. keep = TRUE matches kept, keep = FALSE removed. score addMatches: numeric (length queryValue) data.frame (number rows queryValue) specifying scores matches add. specified, NA used score. isIndex addMatches: specifies queryValue targetValue expected vectors indexes.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of generic objects matches — addMatches","text":"See individual method description details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"creation-and-subsetting","dir":"Reference","previous_headings":"","what":"Creation and subsetting","title":"Representation of generic objects matches — addMatches","text":"Matched MatchedSummarizedExperiment objects returned result matchMz() function. Alternatively, Matched objects can also created Matched function providing query target object well matches data.frame two columns integer indices defining elements query match element target. MatchedSummarizedExperiment objects can created MatchedSummarizedExperiment function providing SummarizedExperiment query parameter. [ subset object selecting query object elements keep parameter . resulting object contain matches selected query elements. target object default returned -. addMatches: add new matches existing object. Parameters queryValue targetValue allow define element(s) query target considered matching. isIndex = TRUE, queryValue targetValue considered integer indices identifying matching elements query target, respectively. Alternatively (isIndex = FALSE) queryValue targetValue can elements columns queryColname targetColname can used identify matching elements. Note case first matching pair added. Parameter score allows provide score match. can numeric score data.frame additional information manually added matches. cases length (number rows) match length queryValue. See examples information. filterMatches: keeps removes matches corresponding certain indexes values query target. queryValue targetValue provided, matches value pairs kept removed. Parameter index allows filter matches providing index matches() matrix. Note filterMatches removes matches matches() matrix Matched object thus alter query target object. See examples information. pruneTarget cleans object removing non-matched target elements.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of generic objects matches — addMatches","text":"$ extracts single variable Matched x. variables can extracted can listed using colnames(x). variables can belong query, target related matches (e.g. score match). query (target) object two dimensional, columns can extracted (prefix \"target_\" used columns target object) otherwise (query respectively target single dimension (e.g. list character) whole object can extracted x$query (x$target). matching scores available variable \"score\". Similar left join query target elements, function returns value query element, eventual duplicated values query elements matching one target element. variables target data.frame extracted, NA reported entries corresponding query elements match target element. See examples details. MatchedSummarizedExperiment columns object's rowData used query columns returned. length returns number query elements. matchedData allows extract multiple variables contained Matched object DataFrame. Parameter columns allows define columns (variables) returned (defaults columns = colnames(object)). single column returned DataFrame constructed way $. , like $, function performs left join variables query target objects returning values query elements (eventually returning duplicated elements query elements matching multiple target elements) values target elements matched respective query elements (NA target element matched query element). MatchedSummarizedExperiment object's rowData used query data frame. matches returns data.frame actual matching information columns \"query_idx\" (index element query), \"target_idx\" (index element target) \"score\" (score match) eventual additional columns. target returns target object. query returns query object. whichTarget returns integer indices elements target match least one element query. whichQuery returns integer indices elements query match least one element target.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of generic objects matches — addMatches","text":"Andrea Vicini, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of generic objects matches — addMatches","text":"","code":"## Creating a Matched object. q1 <- data.frame(col1 = 1:5, col2 = 6:10) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between query row 1 with target row 2 and, query row 2 ## with target rows 2,3,4 and query row 5 with target row 5. mo <- Matched(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                  target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class Matched  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from query object . mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to query ## elements (rows) matched to multiple rows of the target object). The ## value of `col1` is returned for each element (row) in the query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one query ## row are returned and an NA is reported for query rows without matching ## target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\", \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>          col1      col2 target_col1 target_col2 #>     <integer> <integer>   <integer>   <integer> #> 1           1         6          12          18 #> 2           2         7          12          18 #> 2.1         2         7          13          19 #> 2.2         2         7          14          20 #> 3           3         8          NA          NA #> 4           4         9          NA          NA #> 5           5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The example matched object contains all query and all target ## elements (rows). Below we subset the object keeping only query rows that ## are matched to at least one target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one query row mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4  ######## ## Creating a Matched object with a `data.frame` for `query` and a `vector` ## for `target`. The matches are specified in the same way as the example ## before.  q1 <- data.frame(col1 = 1:5, col2 = 6:10) t2 <- 11:16 mo <- Matched(q1, t2, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),     target_idx = c(2L, 2L, 3L, 4L, 5L), score = seq(0.5, 0.9, by = 0.1)))  ## *target* is a simple vector and has thus no columns. The matched values ## from target, if it does not have dimensions and hence column names, can ## be retrieved with `$target` mo$target #> [1] 12 12 13 14 NA NA 15  ## Note that in this case \"target\" is returned by the function `colnames` colnames(mo) #> [1] \"col1\"   \"col2\"   \"target\" \"score\"   ## As before, we can extract all data as a `DataFrame` res <- matchedData(mo) res #> DataFrame with 7 rows and 4 columns #>          col1      col2    target     score #>     <integer> <integer> <integer> <numeric> #> 1           1         6        12       0.5 #> 2           2         7        12       0.6 #> 2.1         2         7        13       0.7 #> 2.2         2         7        14       0.8 #> 3           3         8        NA        NA #> 4           4         9        NA        NA #> 5           5        10        15       0.9  ## Note that the columns of the obtained `DataFrame` are the same as the ## corresponding vectors obtained with `$` res$col1 #> [1] 1 2 2 2 3 4 5 res$target #> [1] 12 12 13 14 NA NA 15  ## Also subsetting and pruning works in the same way as the example above.  mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both object contain however still the full target object: length(target(mo)) #> [1] 6 length(target(mo_sub)) #> [1] 6  ## Reducing the target elements to only those that match at least one query row mo_sub <- pruneTarget(mo_sub) length(target(mo_sub)) #> [1] 4  ######## ## Filtering `Matched` with `filterMatches`  ## Inspecting the matches in `mo`: mo$col1 #> [1] 1 2 2 2 3 4 5 mo$target #> [1] 12 12 13 14 NA NA 15  ## We have thus target *12* matched to both query elements with values 1 and ## 2, and query element 2 is matching 3 target elements. Let's assume we want ## to resolve this multiple mappings to keep from them only the match between ## query 1 (column `\"col1\"` containing value `1`) with target 1 (value `12`) ## and query 2 (column `\"col1\"` containing value `2`) with target 2 (value ## `13`). In addition we also want to keep query element 5 (value `5` in ## column `\"col1\"`) with the target with value `15`: mo_sub <- filterMatches(mo, queryValue = c(1, 2, 5), queryColname = \"col1\",     targetValue = c(12, 13, 15)) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2    target     score #>   <integer> <integer> <integer> <numeric> #> 1         1         6        12       0.5 #> 2         2         7        13       0.7 #> 3         3         8        NA        NA #> 4         4         9        NA        NA #> 5         5        10        15       0.9  ## Alternatively to specifying the matches to filter with `queryValue` and ## `targetValue` it is also possible to specify directly the index of the ## match(es) in the `matches` `data.frame`: matches(mo) #>   query_idx target_idx score #> 1         1          2   0.5 #> 2         2          2   0.6 #> 3         2          3   0.7 #> 4         2          4   0.8 #> 5         5          5   0.9  ## To keep only matches like in the example above we could use: mo_sub <- filterMatches(mo, index = c(1, 3, 5)) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2    target     score #>   <integer> <integer> <integer> <numeric> #> 1         1         6        12       0.5 #> 2         2         7        13       0.7 #> 3         3         8        NA        NA #> 4         4         9        NA        NA #> 5         5        10        15       0.9  ## Note also that, instead of keeping the specified matches, it would be ## possible to remove them by setting `keep = FALSE`. Below we remove ## selected matches from the object: mo_sub <- filterMatches(mo, queryValue = c(2, 2), queryColname = \"col1\",     targetValue = c(12, 14), keep = FALSE) mo_sub$col1 #> [1] 1 2 3 4 5 mo_sub$target #> [1] 12 13 NA NA 15  ######## ## Adding matches using `addMatches`  ## `addMatches` allows to manually add matches. Below we add a new match ## between the `query` element with a value of `1` in column `\"col1\"` and ## the target element with a value of `15`. Parameter `score` allows to ## assign a score value to the match. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = 1.40) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2    target     score #>     <integer> <integer> <integer> <numeric> #> 1           1         6        12       0.5 #> 1.1         1         6        15       1.4 #> 2           2         7        12       0.6 #> 2.1         2         7        13       0.7 #> 2.2         2         7        14       0.8 #> 3           3         8        NA        NA #> 4           4         9        NA        NA #> 5           5        10        15       0.9 ## Matches are always sorted by `query`, thus, the new match is listed as ## second match.  ## Alternatively, we can also provide a `data.frame` with parameter `score` ## which enables us to add additional information to the added match. Below ## we define the score and an additional column specifying that this match ## was added manually. This information will then also be available in the ## `matchedData`. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = data.frame(score = 5, manual = TRUE)) matchedData(mo_add) #> DataFrame with 8 rows and 5 columns #>          col1      col2    target     score    manual #>     <integer> <integer> <integer> <numeric> <logical> #> 1           1         6        12       0.5        NA #> 1.1         1         6        15       5.0      TRUE #> 2           2         7        12       0.6        NA #> 2.1         2         7        13       0.7        NA #> 2.2         2         7        14       0.8        NA #> 3           3         8        NA        NA        NA #> 4           4         9        NA        NA        NA #> 5           5        10        15       0.9        NA  ## The match will get a score of NA if we're not providing any score. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2    target     score #>     <integer> <integer> <integer> <numeric> #> 1           1         6        12       0.5 #> 1.1         1         6        15        NA #> 2           2         7        12       0.6 #> 2.1         2         7        13       0.7 #> 2.2         2         7        14       0.8 #> 3           3         8        NA        NA #> 4           4         9        NA        NA #> 5           5        10        15       0.9  ## Creating a MatchedSummarizedExperiment object. library(SummarizedExperiment) #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians q1 <- SummarizedExperiment(   assays = data.frame(matrix(NA, 5, 2)),   rowData = data.frame(col1 = 1:5, col2 = 6:10),   colData = data.frame(cD1 = c(NA, NA), cD2 = c(NA, NA))) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between row 1 in rowData(q1) with target row 2 and, ## rowData(q1) row 2 with target rows 2,3,4 and rowData(q1) row 5 with target ## row 5. mo <- MatchedSummarizedExperiment(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                 target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class MatchedSummarizedExperiment  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from rowData(q1). mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to rows of ## rowData(q1) matched to multiple rows of the target data.frame t1. The ## value of `col1` is returned for each row in the rowData of query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one row in ## rowData of query are returned and an NA is reported for those without ## matching target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\", \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>        col1      col2 target_col1 target_col2 #>   <integer> <integer>   <integer>   <integer> #> 1         1         6          12          18 #> 2         2         7          12          18 #> 2         2         7          13          19 #> 2         2         7          14          20 #> 3         3         8          NA          NA #> 4         4         9          NA          NA #> 5         5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The example MatchedSummarizedExperiment object contains all rows in the ## rowData of the SummarizedExperiment and all target rows. Below we subset the ## object keeping only rows that are matched to at least one target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now a SummarizedExperiment with only 3 rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains a SummarizedExperiment with all 5 rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one in the rowData of query mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of Spectra matches — MatchedSpectra","title":"Representation of Spectra matches — MatchedSpectra","text":"Matches query target spectra can represented MatchedSpectra object. Functions like matchSpectra() function return type object. default, data accessors work left joins query target spectra, .e. values returned query spectrum eventual duplicated entries (values) query spectrum matches one target spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"MatchedSpectra(   query = Spectra(),   target = Spectra(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score =     numeric()) )  # S4 method for MatchedSpectra spectraVariables(object)  # S4 method for MatchedSpectra colnames(x)  # S4 method for MatchedSpectra $(x, name)  # S4 method for MatchedSpectra spectraData(object, columns = spectraVariables(object))  # S4 method for MatchedSpectra matchedData(object, columns = spectraVariables(object), ...)  # S4 method for MatchedSpectra addProcessing(object, FUN, ..., spectraVariables = character())  # S4 method for MatchedSpectra plotSpectraMirror(x, xlab = \"m/z\", ylab = \"intensity\", main = \"\", ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of Spectra matches — MatchedSpectra","text":"query Spectra query spectra. target Spectra spectra query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target Spectra. object MatchedSpectra object. x MatchedSpectra object. name $: name spectra variable extract. columns spectraData: character vector spectra variable names extracted. ... addProcessing: additional parameters function FUN. plotSpectraMirror: additional parameters passed plotting functions. FUN addProcessing: function applied peak matrix spectrum object. See Spectra() details. spectraVariables addProcessing: character additional spectra variables passed along function defined FUN. See Spectra() details. xlab plotSpectraMirror: label x-axis. ylab plotSpectraMirror: label y-axis. main plotSpectraMirror: optional title plot.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of Spectra matches — MatchedSpectra","text":"See individual method desciption details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"creation-and-subsetting","dir":"Reference","previous_headings":"","what":"Creation and subsetting","title":"Representation of Spectra matches — MatchedSpectra","text":"MatchedSpectra objects can created MatchedSpectra function providing query target Spectra well data.frame [ subset MatchedSpectra selecting query spectra keep parameter . target spectra default returned -. pruneTarget cleans MatchedSpectra object removing non-matched target spectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of Spectra matches — MatchedSpectra","text":"$ extracts single spectra variable MatchedSpectra x. Use spectraVariables get available spectra variables. Prefix \"target_\" used spectra variables target Spectra. matching scores available spectra variable \"score\". Similar left join query target spectra, function returns value query spectrum eventual duplicated values query spectra matching one target spectrum. spectra variables target spectra extracted, NA reported query spectra match target spectra. See examples details. length returns number query spectra. matchedData spectraData . spectraData returns spectra variables query /target Spectra DataFrame. Parameter columns allows define variables returned (defaults columns = spectraVariables(object)), spectra variable names target spectra need prefixed target_ (e.g. target_msLevel get MS level target spectra). score matching function returned spectra variable \"score\". Similar $, function performs left join spectra variables query target spectra returning values query spectra (eventually returning duplicated elements query spectra matching multiple target spectra) values target spectra matched respective query spectra. See help $ examples details. spectraVariables returns available spectra variables query target spectra. prefix \"target_\" used label spectra variables target spectra (e.g. name spectra variable MS level target spectra called \"target_msLevel\"). target returns target Spectra. query returns query Spectra. whichTarget returns integer indices spectra target match least spectrum query. whichQuery returns integer indices spectra query match least spectrum target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"data-manipulation-and-plotting","dir":"Reference","previous_headings":"","what":"Data manipulation and plotting","title":"Representation of Spectra matches — MatchedSpectra","text":"addProcessing: add processing step query target Spectra object. Additional parameters FUN can passed via .... See addProcessing documentation Spectra() information. plotSpectraMirror: creates mirror plot query matching target spectrum. Can applied MatchedSpectra single query spectrum. Additional plotting parameters can passed ....","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of Spectra matches — MatchedSpectra","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"## Creating a dummy MatchedSpectra object. library(Spectra) df1 <- DataFrame(     msLevel = 2L, rtime = 1:10,     spectrum_id = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\")) df2 <- DataFrame(     msLevel = 2L, rtime = rep(1:10, 20),     spectrum_id = rep(c(\"A\", \"B\", \"C\", \"D\", \"E\"), 20)) sp1 <- Spectra(df1) sp2 <- Spectra(df2) ## Define matches between query spectrum 1 with target spectra 2 and 5, ## query spectrum 2 with target spectrum 2 and query spectrum 4 with target ## spectra 8, 12 and 15. ms <- MatchedSpectra(     sp1, sp2, matches = data.frame(query_idx = c(1L, 1L, 2L, 4L, 4L, 4L),                                    target_idx = c(2L, 5L, 2L, 8L, 12L, 15L),                                    score = 1:6))  ## Which of the query spectra match at least one target spectrum? whichQuery(ms) #> [1] 1 2 4  ## Extracting spectra variables: accessor methods for spectra variables act ## as \"left joins\", i.e. they return a value for each query spectrum, with ## eventually duplicated elements if one query spectrum matches more than ## one target spectrum.  ## Which target spectrum matches at least one query spectrum? whichTarget(ms) #> [1]  2  5  8 12 15  ## Extracting the retention times of the query spectra. ms$rtime #>  [1]  1  1  2  3  4  4  4  5  6  7  8  9 10  ## We have duplicated retention times for query spectrum 1 (matches 2 target ## spectra) and 4 (matches 3 target spectra). The retention time is returned ## for each query spectrum.  ## Extracting retention times of the target spectra. Note that only retention ## times for target spectra matching at least one query spectrum are returned ## and an NA is reported for query spectra without matching target spectrum. ms$target_rtime #>  [1]  2  5  2 NA  8  2  5 NA NA NA NA NA NA  ## The first query spectrum matches target spectra 2 and 5, thus their ## retention times are returned as well as the retention time of the second ## target spectrum that matches also query spectrum 2. The 3rd query spectrum ## does match any target spectrum, thus `NA` is returned. Query spectrum 4 ## matches target spectra 8, 12, and 15, thus the next reported retention ## times are those from these 3 target spectra. None of the remaining 6 query ## spectra matches any target spectra and thus `NA` is reported for each of ## them.  ## `spectraData` can be used to extract all (or selected) spectra variables ## from the object. Same as with `$`, a left join between the specta ## variables from the query spectra and the target spectra is performed. The ## prefix `\"target_\"` is used to label the spectra variables from the target ## spectra. Below we extract selected spectra variables from the object. res <- spectraData(ms, columns = c(\"rtime\", \"spectrum_id\",     \"target_rtime\", \"target_spectrum_id\")) res #> DataFrame with 13 rows and 4 columns #>         rtime spectrum_id target_rtime target_spectrum_id #>     <integer> <character>    <integer>        <character> #> 1           1           a            2                  B #> 2           1           a            5                  E #> 3           2           b            2                  B #> 4           3           c           NA                 NA #> 5           4           d            8                  C #> ...       ...         ...          ...                ... #> 9           6           f           NA                 NA #> 10          7           g           NA                 NA #> 11          8           h           NA                 NA #> 12          9           i           NA                 NA #> 13         10           j           NA                 NA res$spectrum_id #>  [1] \"a\" \"a\" \"b\" \"c\" \"d\" \"d\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" res$target_spectrum_id #>  [1] \"B\" \"E\" \"B\" NA  \"C\" \"B\" \"E\" NA  NA  NA  NA  NA  NA   ## Again, all values for query spectra are returned and for query spectra not ## matching any target spectrum NA is reported as value for the respecive ## variable.  ## The example matched spectra object contains all query and all target ## spectra. Below we subset the object keeping only query spectra that are ## matched to at least one target spectrum. ms_sub <- ms[whichQuery(ms)]  ## ms_sub contains now only 3 query spectra: length(query(ms_sub)) #> [1] 3  ## while the original object contains all 10 query spectra: length(query(ms)) #> [1] 10  ## Both object contain however still the full target `Spectra`: length(target(ms)) #> [1] 200 length(target(ms_sub)) #> [1] 200  ## With the `pruneTarget` we can however reduce also the target spectra to ## only those that match at least one query spectrum ms_sub <- pruneTarget(ms_sub) length(target(ms_sub)) #> [1] 5"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal page for hidden aliases — colnames,MatchedSummarizedExperiment-method","title":"Internal page for hidden aliases — colnames,MatchedSummarizedExperiment-method","text":"S4 methods require documentation entry clutter index.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal page for hidden aliases — colnames,MatchedSummarizedExperiment-method","text":"","code":"# S4 method for MatchedSummarizedExperiment colnames(x)  # S4 method for MatchedSummarizedExperiment $(x, name)  # S4 method for MatchedSummarizedExperiment matchedData(object, columns = colnames(object), ...)  # S4 method for MatchedSummarizedExperiment filterMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE,   ... )  # S4 method for MatchedSummarizedExperiment addMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   score = data.frame(),   isIndex = FALSE )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal page for hidden aliases — colnames,MatchedSummarizedExperiment-method","text":"applicable","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":null,"dir":"Reference","previous_headings":"","what":"Chemical Formula Matching — matchFormula","title":"Chemical Formula Matching — matchFormula","text":"matchFormula method matches chemical formulas different inputs (parameter query target). comparison formulas normalized using MetaboCoreUtils::standardizeFormula(). Inputs can either character data.frame containing column formulas. case data.frames parameter formulaColname needs used specify name column containing chemical formulas.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chemical Formula Matching — matchFormula","text":"","code":"matchFormula(query, target, ...)  # S4 method for character,character matchFormula(query, target, BPPARAM = SerialParam())  # S4 method for data.frameOrSimilar,data.frameOrSimilar matchFormula(   query,   target,   formulaColname = c(\"formula\", \"formula\"),   BPPARAM = SerialParam() )  # S4 method for character,data.frameOrSimilar matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )  # S4 method for data.frameOrSimilar,character matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chemical Formula Matching — matchFormula","text":"query character data.frame chemical formulas search. target character data.frame chemical formulas compare . ... currently ignored BPPARAM parallel processing setup. See BiocParallel::bpparam() details. formulaColname character name column containing chemical formulas. Can length 1 query target data.frames name column chemical formulas . different columns used, formulaColname[1] can used define column name query formulaColname[2] one target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chemical Formula Matching — matchFormula","text":"Matched object representing result.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Chemical Formula Matching — matchFormula","text":"Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chemical Formula Matching — matchFormula","text":"","code":"## input formula query <- c(\"H12C6O6\", \"C11H12O2\", \"HN3\") target <- c(\"HCl\", \"C2H4O\", \"C6H12O6\")  query_df <- data.frame(     formula = c(\"H12C6O6\", \"C11H12O2\", \"HN3\"),     name = c(\"A\", \"B\", \"C\") ) target_df <- data.frame(     formula = c(\"HCl\", \"C2H4O\", \"C6H12O6\"),     name = c(\"D\", \"E\", \"F\") )  ## character vs character matches <- matchFormula(query, target) matchedData(matches) #> DataFrame with 3 rows and 3 columns #>               query      target     score #>         <character> <character> <numeric> #> C6H12O6     H12C6O6     C6H12O6         1 #> NA         C11H12O2          NA        NA #> NA.1            HN3          NA        NA  ## data.frame vs data.frame matches <- matchFormula(query_df, target_df) matchedData(matches) #> DataFrame with 3 rows and 5 columns #>       formula        name target_formula target_name     score #>   <character> <character>    <character> <character> <numeric> #> 1     H12C6O6           A        C6H12O6           F         1 #> 2    C11H12O2           B             NA          NA        NA #> 3         HN3           C             NA          NA        NA ## data.frame vs character matches <- matchFormula(query_df, target) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>       formula        name      target     score #>   <character> <character> <character> <numeric> #> 1     H12C6O6           A     C6H12O6         1 #> 2    C11H12O2           B          NA        NA #> 3         HN3           C          NA        NA ## character vs data.frame matches <- matchFormula(query, target_df) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>            query target_formula target_name     score #>      <character>    <character> <character> <numeric> #> 3        H12C6O6        C6H12O6           F         1 #> NA      C11H12O2             NA          NA        NA #> NA.1         HN3             NA          NA        NA"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":null,"dir":"Reference","previous_headings":"","what":"m/z matching — MzParam","title":"m/z matching — MzParam","text":"matchMz method matches (compares) m/z values MS1 data table (parameter query) theoretical m/z values (reference) compounds (parameter target) considering also retention times. approach used perform comparison additional settings matching can defined param. Available matching approaches respective param objects : Mass2MzParam: match m/z values reference compounds (exact) mass known. matching, m/z values calculated mass compounds target table specified adducts (parameter adduct parameter object). query must data.frame column containing m/z values (column name can specified parameter mzColname defaults \"mz\") numeric m/z values features. target data.frame must contain column (monoisotopic) mass compounds (column name can specified parameter massColname defaults \"exactmass\") Mass2MzParam's parameter adducts allows define expected adducts (defaults adducts = \"[M+H]+\" adducts available MetaboCoreUtils::adducts() supported). Parameter tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values. Mass2MzRtParam: match m/z retention time values reference compounds (exact) mass retention time known. matching, m/z values calculated mass compounds target table specified adducts (parameter adduct parameter object). retention time considered equal different adducts compound. query must data.frame m/z retention time values features. names columns containing information can specified parameters mzColname rtColname default \"mz\" \"rt\", respectively). target must data.frame (monoisotopic) mass retention time compound. names columns containing information can specified parameters massColname rtColname default \"exactmass\" \"rt\", respectively. Mass2MzRtParam's parameter adducts allows define expected adducts (defaults adducts = \"[M+H]+\" adducts available MetaboCoreUtils::adducts() supported). Parameter tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values; parameter toleranceRt allows specify maximal acceptable difference query target retention time values. MzParam: match m/z values reference compounds m/z known. query must either data.frame column containing m/z values (name can specified parameter mzColname, default mzColname = \"mz\") numeric m/z values features. holds target. MzParam parameters tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values. MzRtParam: match m/z retention time values reference compounds m/z retention time known. query must data.frame SummarizedExperiment. data.frame one case SummarizedExperiment rowData must columns containing m/z retention times features. names respective columns can specified parameters mzColname rtColname default \"mz\" \"rt\", respectively.target must data.frame information m/z retention time.MzRtParam parameters tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values; MzRtParam parameter toleranceRt allows specify maximal acceptable difference query target retention time values.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"m/z matching — MzParam","text":"","code":"MzParam(tolerance = 0, ppm = 5)  Mass2MzParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5)  Mass2MzRtParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5, toleranceRt = 0)  MzRtParam(tolerance = 0, ppm = 0, toleranceRt = 0)  matchMz(query, target, param, ...)  # S4 method for numeric,numeric,Mass2MzParam matchMz(query, target, param, BPPARAM = SerialParam())  # S4 method for numeric,data.frameOrSimilar,Mass2MzParam matchMz(   query,   target,   param,   massColname = \"exactmass\",   BPPARAM = SerialParam() )  # S4 method for data.frameOrSimilar,numeric,Mass2MzParam matchMz(query, target, param, BPPARAM = SerialParam(), mzColname = \"mz\")  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mass2MzParam matchMz(   query,   target,   param,   mzColname = \"mz\",   massColname = \"exactmass\",   BPPARAM = SerialParam() )  # S4 method for numeric,numeric,MzParam matchMz(query, target, param, BPPARAM = SerialParam())  # S4 method for numeric,data.frameOrSimilar,MzParam matchMz(query, target, param, mzColname = \"mz\", BPPARAM = SerialParam())  # S4 method for data.frameOrSimilar,numeric,MzParam matchMz(query, target, param, mzColname = \"mz\", BPPARAM = SerialParam())  # S4 method for data.frameOrSimilar,data.frameOrSimilar,MzParam matchMz(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   BPPARAM = SerialParam() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,Mass2MzRtParam matchMz(   query,   target,   param,   massColname = \"exactmass\",   mzColname = \"mz\",   rtColname = c(\"rt\", \"rt\"),   BPPARAM = SerialParam() )  # S4 method for data.frameOrSimilar,data.frameOrSimilar,MzRtParam matchMz(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   BPPARAM = SerialParam() )  # S4 method for SummarizedExperiment,ANY,Param matchMz(   query,   target,   param,   mzColname = \"mz\",   rtColname = \"rt\",   BPPARAM = SerialParam() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"m/z matching — MzParam","text":"tolerance param object: numeric(1) defining maximal acceptable absolute difference m/z values consider matching. ppm param object: numeric(1) defining maximal acceptable m/z-dependent difference (parts-per-million) m/z values consider matching. adducts Mass2MzParam Mass2MzRtParam: either character names adducts data.frame adduct definition. parameter used calculate m/z target compounds' masses. Custom adduct definitions can passed adduct parameter form data.frame. data.frame expected columns \"mass_add\" \"mass_multi\" defining additive multiplicative part calculation. See MetaboCoreUtils::adducts() expected format use MetaboCoreUtils::adductNames(\"positive\") MetaboCoreUtils::adductNames(\"negative\") valid adduct names. toleranceRt Mass2MzRtParam MzRtParam: numeric(1) defining maximal acceptable absolute difference retention time values consider matching. query feature table containing information MS1 features. Can data.frame (mandatory column names \"mz\") numeric m/z values. matching based m/z retention time can performed column \"rt\" present query target. target compound table metabolites compare . param parameter object defining matching approach containing settings approach. See description details. ... currently ignored. BPPARAM parallel processing setup. See BiocParallel::bpparam() details. massColname character(1) name column containing mass compounds. Defaults massColname = \"exactmass\". mzColname character(1) name column containing m/z values. Defaults mzColname = \"mz\". rtColname character(1) name column containing retention times compounds. Defaults rtColname = \"rt\".","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"m/z matching — MzParam","text":"Matched object representing result. evaluate match object contains m/z error ppm (variable \"ppm_error\") well difference query target m/z (variable \"score\"). difference query target retention time (variable \"score_rt\"also present retention time considered match. Thus, match, negative value \"score\" (\"score_rt\") indicates m/z (retention time) query element smaller matched target element.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"m/z matching — MzParam","text":"Andrea Vicini, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchMz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"m/z matching — MzParam","text":"","code":"library(MetaboCoreUtils) ## Create a simple \"target/reference\" compound table target_df <- data.frame(    name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),    formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),    exactmass = c(204.089878, 131.094629, 131.094629) )  ## Create a \"feature\" table with m/z of features. We calculate m/z for ## certain adducts of some of the compounds in the reference table. fts <- data.frame(     feature_id = c(\"FT001\", \"FT002\", \"FT003\"),     mz = c(mass2mz(204.089878, \"[M+H]+\"),            mass2mz(131.094629, \"[M+H]+\"),            mass2mz(204.089878, \"[M+Na]+\") + 1e-6))  ## Define the parameters for the matching parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 20) res <- matchMz(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079  Tryptophan     C11H12N2O2          204.090 #>          adduct     score  ppm_error #>     <character> <numeric>  <numeric> #> 1        [M+H]+     0e+00 0.00000000 #> 2        [M+H]+     0e+00 0.00000000 #> 2.1      [M+H]+     0e+00 0.00000000 #> 3       [M+Na]+     1e-06 0.00440375  ## We have thus matches of FT002 to two different compounds (but with the ## same mass).  ## We repeat the matching requiring an exact match parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 0) res <- matchMz(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079          NA             NA               NA #>          adduct     score ppm_error #>     <character> <numeric> <numeric> #> 1        [M+H]+         0         0 #> 2        [M+H]+         0         0 #> 2.1      [M+H]+         0         0 #> 3            NA        NA        NA  ## The last feature could thus not be matched to any compound.  ## At last we use also different adduct definitions. parm <- Mass2MzParam(     adducts = c(\"[M+K]+\", \"[M+Li]+\"),     tolerance = 0,     ppm = 20) res <- matchMz(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 0  #> Number of query objects: 3 (0 matched) #> Number of target objects: 3 (0 matched)  matchedData(res) #> DataFrame with 3 rows and 8 columns #>    feature_id        mz target_name target_formula target_exactmass      adduct #>   <character> <numeric> <character>    <character>        <numeric> <character> #> 1       FT001   205.097          NA             NA               NA          NA #> 2       FT002   132.102          NA             NA               NA          NA #> 3       FT003   227.079          NA             NA               NA          NA #>       score       ppm #>   <numeric> <numeric> #> 1        NA        NA #> 2        NA        NA #> 3        NA        NA  ## No matches were found.  ## We can also match a \"feature\" table with a target data.frame taking into ## account both m/z and retention time values. target_df <- data.frame(   name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),   formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),   exactmass = c(204.089878, 131.094629, 131.094629),   rt = c(150, 140, 140) )  fts <- data.frame(   feature_id = c(\"FT001\", \"FT002\", \"FT003\"),   mz = c(mass2mz(204.089878, \"[M+H]+\"),          mass2mz(131.094629, \"[M+H]+\"),          mass2mz(204.089878, \"[M+Na]+\") + 1e-6),   rt = c(150, 140, 150.1) )  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0)  res <- matchMz(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1          NA             NA               NA #>     target_rt      adduct     score ppm_error  score_rt #>     <numeric> <character> <numeric> <numeric> <numeric> #> 1         150      [M+H]+         0         0         0 #> 2         140      [M+H]+         0         0         0 #> 2.1       140      [M+H]+         0         0         0 #> 3          NA          NA        NA        NA        NA  ## FT003 could not be matched to any compound, FT002 was matched to two ## different compounds (but with the same mass).  ## We repeat the matching allowing a positive tolerance for the matches ## between rt values  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0.1)  res <- matchMz(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>     target_rt      adduct     score  ppm_error  score_rt #>     <numeric> <character> <numeric>  <numeric> <numeric> #> 1         150      [M+H]+     0e+00 0.00000000       0.0 #> 2         140      [M+H]+     0e+00 0.00000000       0.0 #> 2.1       140      [M+H]+     0e+00 0.00000000       0.0 #> 3         150     [M+Na]+     1e-06 0.00440375       0.1  ## Also FT003 was matched in this case  ## It is also possible to match directly m/z values mz1 <- c(12, 343, 23, 231) mz2 <- mz1 + rnorm(4, sd = 0.001)  res <- matchMz(mz1, mz2, MzParam(tolerance = 0.001))  matchedData(res) #> DataFrame with 4 rows and 4 columns #>       query    target        score ppm_error #>   <numeric> <numeric>    <numeric> <numeric> #> 1        12   12.0006 -0.000553161  46.09461 #> 2       343  343.0005 -0.000513483   1.49703 #> 3        23   22.9995  0.000465554  20.24189 #> 4       231  231.0009 -0.000880111   3.80999"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral matching — matchSpectra","title":"Spectral matching — matchSpectra","text":"matchSpectra method matches (compares) spectra query target based settings specified param returns result MatchedSpectra object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral matching — matchSpectra","text":"","code":"matchSpectra(query, target, param, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral matching — matchSpectra","text":"query Spectra object (experimental) spectra. target spectral data compare . Can another Spectra. param parameter object containing settings matching (e.g. eventual prefiltering settings, cut-value similarity spectra considered matching etc). ... optional parameters.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral matching — matchSpectra","text":"MatchedSpectra object spectra matching results.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spectral matching — matchSpectra","text":"Johannes Rainer","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.7","title":"MetaboAnnotation 0.99","text":"Add formula matching functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.5","title":"MetaboAnnotation 0.99","text":"Add parameter ... plotSpectraMirror. Definitions “score”, “score_rt” changed difference (sign) query target m/z retention time respectively. \"ppm_error\" becomes error without sign.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.4","title":"MetaboAnnotation 0.99","text":"Add matches m/z error (variable \"ppm_error\") Matched object returned matchMz.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.3","title":"MetaboAnnotation 0.99","text":"Address Herve’s comments.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.11","title":"MetaboAnnotation 0.2","text":"Fix calculation correct number rows/columns plot plotSpectraMirror.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.10","title":"MetaboAnnotation 0.2","text":"Add parameter toleranceRt CompareSpectraParam enable retention time-based pre-filtering (issue #35).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.9","title":"MetaboAnnotation 0.2","text":"Add support manually defined adducts Mass2MzParam (issue #41).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.8","title":"MetaboAnnotation 0.2","text":"Add parameter THRESHFUN_REVERSE MatchForwardReverseParam allow filtering results forward reverse score (issue #37).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.7","title":"MetaboAnnotation 0.2","text":"Performance improvement matchSpectra precursor m/z filter used (issue #38). Report number matching peaks matchSpectra,MatchForwardReverseParam (issue #36).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.6","title":"MetaboAnnotation 0.2","text":"Fix bug matchSpectra wrongly calculating acceptable m/z difference tolerance > 0 (issue #34). Fix proposed Hugo Varet (@hvaret).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.5","title":"MetaboAnnotation 0.2","text":"Improve performance matchMz. Rename queryColumn targetColumn queryColname targetColname.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.4","title":"MetaboAnnotation 0.2","text":"Support data.frame, DataFrame matrix matchMz. Add addMatches filterMatches functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.3","title":"MetaboAnnotation 0.2","text":"Fixes MatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.2","title":"MetaboAnnotation 0.2","text":"Add MatchedSummarizedExperiment.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.1","title":"MetaboAnnotation 0.2","text":"Rename TargetMass2MzParam Mass2MzParam.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-11","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.0","title":"MetaboAnnotation 0.2","text":"Add support matching m/z m/z m/z addition retention times matchMz.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-0","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.4","title":"MetaboAnnotation 0.0","text":"Fix vignette, documentations unit tests.","code":""}]
